© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.2

# 第一章｜AI Coding 的真正问题：当决策与责任发生错位

在讨论任何流程、模板或“最佳实践”之前，我们必须先确立一个**不会随技术进步而改变的工程公理**：

**在任何真实的软件工程中，决策与责任不可分离。**
谁做出关键判断，谁就必须承担该判断在时间维度上所产生的长期后果。

这一点并不取决于工具是否先进，也不取决于执行是否高效。
它是工程系统得以长期存在的前提条件。

---

## 从一个公理出发

一旦承认“责任不可外包”，我们就必须面对一个直接而不舒服的推论：

> **凡是不承担工程后果的角色，都不具备在高责任判断中拥有最终决策权的合法性。**

正是这一点，构成了当今 AI Coding 的核心矛盾——
**AI 无法承担工程责任，却被默认参与了工程决策。**

大多数 AI Coding 在真实工程中的不稳定性，并非源于模型能力不足，
而是源于这一结构性错配。

---

## 为什么能力的提升解决不了这个问题

当前关于 AI 编程的讨论，几乎全部集中在能力层面：

- 模型是否足够聪明
- 上下文是否足够长
- prompt 是否足够精巧

但即便假设一个理想化前提——
AI 拥有无限上下文、完全理解需求、能够生成近乎完美的代码——
它依然无法解决一个根本问题：

**AI 无法为工程结果承担责任。**

在真实工程中，架构错误、技术债、维护成本和协作失败的后果，
最终只能由人类承担。
只要责任无法外包，最终决定权就不可能被彻底外包。

能力可以被外包，
判断可以被辅助，
但责任永远无法转移。

---

## 0 → 1 与 1 → 100：责任结构的断层

这一矛盾之所以在实践中长期被忽视，是因为人们混淆了两个责任结构完全不同的阶段。

当前主流 AI Coding 在 **0 → 1** 场景中表现极其出色：
快速把一个想法变成可运行的 demo、小工具或一次性脚本。

在这一阶段：

- 决策后果短暂
- 可以推倒重来
- 几乎没有长期维护义务

因此，即便 AI 在实现过程中隐式地做出一些判断，也不会立即引发结构性问题。

但真实的软件工程并不止步于此。
真正困难、也真正重要的是 **1 → 100**：

- 代码是否在数月后仍然可读
- 抽象是否能够承载变化
- 系统是否可以被他人接手
- 历史判断是否可追溯
- 错误是否可定位和修复

在这一阶段，每一个关键判断都会在时间维度上持续产生后果。
这并不是工程“复杂度”的增加，
而是**责任结构发生了质变**。

---

## 失效的并不是 AI，而是协作范式

这也正是为什么大量资深工程师对 AI Coding 持审慎态度。

他们并非否认 AI 的能力，
而是天然警惕责任体系被悄然破坏。

当前主流 AI Coding 隐含着一个几乎从未被系统性审视的假设：

> **人负责提需求，AI 负责代替完成。**

其结果是——
人在请求，
而 AI 在实现过程中**替代性地做出判断**。

在高责任工程中，这种模式必然导致：

- 判断在实现阶段悄然发生
- 设计取舍未被显式表达
- 原始意图被代码细节反向塑形
- 系统在没有清晰冻结点的情况下持续演化

最终失控的并不是代码是否“能跑”，
而是系统在不知不觉中，被一个不承担责任的执行体重塑。

雪上加霜的是，在主流的 AI 协作模式下，人类虽然获得了‘聊天的轻松体验’，却陷入了心智角色频繁切换的陷阱：

你必须在一瞬间是提出需求的产品经理，下一秒切换为决定架构的高级工程师，转头又要充当严苛审核代码的质检工程师。

人类工程师被迫在完全不同的认知尺度下进行高频决策。这种缺乏结构化约束的协作方式，不仅无法沉淀有效的工程判断，反而让工程师在‘被代码反向塑形’的过程中疲于奔命。

---

## 更强的 AI，只会放大这个问题

更值得警惕的是，更聪明的 AI 并不能解决这一问题，反而可能放大风险。

AI 越强，
越容易在实现过程中替你选择看起来“更优”的结构，
越容易在局部做出未经确认的取舍，
越容易在短期效率与长期责任之间，替你做出隐性权衡。

这些行为在短期内可能提升产出速度，
却同时模糊了判断边界，隐藏了责任归属，
使系统的演化路径不可控。

而 AI 永远无法为这些判断承担长期后果。

---

## 这是一个治理问题，而不是技术问题

这种责任错位并非 AI 编程特有。
它几乎一比一地复刻了人类组织中早已被反复验证的治理失败模式。

在任何成熟的组织中，
决策权的分配从来不是基于能力上限，
而是基于**失败后果是否仍然落在责任边界之内**。

一个不承担长期后果的角色，
即便在统计意义上“更可能正确”，
也不应被赋予高责任判断的最终裁量权。

工程世界并不特殊，AI 也不例外。

---

## 问题的本质与出路

因此，今天 AI Coding 的不稳定，并不是因为 AI 还不够强，
而是因为我们允许一个不承担责任的执行体，
在 **1 → 100 的工程中参与高责任判断**。

这是一个协作结构层面的错误，
而不是一个可以通过更好模型解决的问题。

解决这一问题的方向也因此变得清晰：

> **不是限制 AI 的能力，
> 而是重新对齐决策权与责任的归属。**

只要 AI 不承担工程后果，
它的判断权就必须被限制在与其责任相匹配的范围内；
而真正影响系统长期演化的判断，
必须由能够承担后果的一方做出。


# 第二章 | 从问题到解法：在工程约束下收敛的协作结构

在第一章，我们已经完成了一件关键的事情：

我们不再讨论“AI 能不能写好代码”，
而是将问题重新定位为一个更根本、也更稳定的工程问题——

在 AI 参与软件工程的前提下，一个责任体系如何才能在结构上成立。

如果“决定与责任不可分离”这一工程公理成立，那么问题就不再是“要不要用 AI”，而必然变成：

在什么样的协作结构下使用 AI，工程才能在 1 → 100 的时间尺度上不失控。

这意味着，任何可行解，都必须首先满足一组不可回避的工程约束。

---

## 一、把问题工程化：任何解法都必须回答的三个问题

在任何工程系统中，所谓“责任问题”并不是抽象的道德讨论，而是可以被还原为三个具体、可验证的问题：

- 谁拥有决策权？
- 决策发生在什么阶段？
- 决策失败的后果由谁承担？

如果这三个问题无法被明确回答，那么所谓的“协作流程”“最佳实践”，就只能依赖个人自觉，而无法形成稳定、可复制的工程约束。

传统 AI Coding 的核心问题正是在于此：

这三个问题从未被显式回答，
却在实现过程中被不断隐式解决、反复修改、相互覆盖。

---

## 二、额外工程约束：不是所有“正确”的解法都能成立

到这里为止，我们只是确认了一件事：

高责任决策不能在错误的阶段，由错误的主体发生。

但这一结论本身，并不足以构成一个可用的工程解法。

在真实工程中，一个解法即便在逻辑上正确，只要违背工程现实或人类工作方式，同样无法长期成立。因此，在继续推导之前，我们必须引入一组额外的工程约束，用以限定可行解空间。

这些约束不是理想化目标，而是任何可落地方案都必须同时满足的前提条件。

---

### 约束一：AI 必须被引入

我们讨论的不是回退到传统开发方式。

解法必须以内建 AI 协作为前提，而不是通过不使用 AI 来规避问题。
任何要求工程师重新承担全部实现、分析与执行工作的方案，都不在讨论范围之内。

---

### 约束二：人类必须轻松

解法不能通过将心智负担重新压回人类工程师身上来换取稳定性。

如果一个方案要求工程师长期处于高度形式化、重流程、重文书的工作状态，那么它在现实中同样不可持续。

换言之，工程稳定性不能以牺牲工程师的便利性为代价。
如果引入这一解法不能显著降低工程师在实现阶段的心智负担，那么这个解法本身就不成立。

---

### 约束三：重要决策必须由人类完成

所有可能导致长期结构性后果的高责任判断，只能由承担后果的人类工程师完成。

任何 AI 都不应被允许在不受约束的情况下做出此类判断。

---

### 约束四：AI 被允许做决策，但不能推翻人类的决策

这个解法不能通过禁止 AI 决策来获得安全性。

AI 应当被允许在低责任空间内做出大量决策，以解放人类工程师；
但与此同时，人类工程师已经做出的决策不得被 AI 的后续行为所影响、修改或隐式推翻。

---

### 约束五：AI 的决策风险必须可控

AI 在执行过程中所拥有的决策自由，必须被明确限定在一个可审计、可回溯的范围之内。

任何无法界定其裁量边界、无法判断其是否越权的决策行为，都是不可接受的。

---

### 约束六：解法必须与问题域无关

这一协作结构不应只适用于某一类特定问题域或技术类型。

只要一个问题中存在需要被承担长期后果的判断，该结构就应当能够被应用。

是否启用这一解法，由人类工程师根据问题性质自行判断；
但一旦启用，其责任划分、决策冻结与授权审计的逻辑，不应随问题域、技术栈或实现形式发生变化。

---

## 三、从约束到解决方案

在上述约束下，我们可以逐步收敛可行解空间。

首先，任何没有 AI 参与的编程方式都被直接排除。

其次，根据约束四，即 AI 的决策不能反向影响人类工程师的决策，我们可以发现，这一要求在结构上与软件工程中的依赖倒置原则一致：

高层决策不能依赖底层实现，
而必须通过稳定接口进行隔离，双方共同依赖该接口。

在这里，这个接口不能是代码，也不能是对话状态，而只能是一个显式、可冻结、可审计的工程产物。

---

### 决策接口的外显化

一个自然且必要的选择是：

将人类工程师做出的关键决策外显为文档，并将该文档作为人类与 AI 之间的唯一决策接口。
对话天然是低熵的、弥散的。在漫长的对话中，早期的工程约束往往会被后期的实现细节所淹没。
外显化文档的本质是‘决策冷冻’——通过将流动的对话固化为静态的文档，我们人为地制造了一个熵减的过程，确保系统的演化路径始终锚定在初始的工程设计之上。
通过文档来杜绝Coding Agent接触到决策上下文的可能，防止讨论过程中的噪音污染Coding Agent。


在工程上，这里的文档并非单一形态，而是具有明确层级关系的两类约束载体：

一、设计文档（Design Document）
用于约束人类工程师自身，回答的是：
我想要什么，以及我不允许发生什么。

该文档承载所有高责任判断与长期结构性决策，是人类工程师对系统未来所做出的承诺。

二、任务说明书（Task Specification）
用于约束 Coding Agent，回答的是：
你该干什么，以及你绝不能干什么。

该文档从设计文档中派生而来，是对执行行为的具体授权。

在这两类文档之间，存在明确且不可逆的效力层级关系：

设计文档的效力高于任务说明书。

- 任务说明书只能细化、拆解设计文档中的已冻结决策
- 不得引入新的设计判断
- 不得弱化或修改设计文档中已明确的约束

当二者出现任何不一致时，一律以设计文档为准。

Coding Agent 只能依据任务说明书执行；
任何未被任务说明书明确授权的行为，
即便可以从设计文档中推测得到，
在执行阶段一律视为未授权行为。

通过这一分层结构，人类决策、执行授权与 AI 行为边界被显式区分并永久锁定。

---

### Vibe Writing：在不增加负担的前提下完成决策冻结

在人类工程师参与的阶段，我们仍然允许 AI 作为认知放大器存在。

人类工程师可以通过与 AI 的自然语言讨论来澄清需求、探索方案、比较权衡。
这一过程保持了 Vibe Coding 的轻松性。

但这一阶段的产出不再是代码，而是文档。

这一过程可以被称为 Vibe Writing。

需要强调的是，这里的文档并不是穷尽实现细节的规格说明，
而是人类高责任判断的最小外显集合。

---

### 执行与审计：受限自由下的高效实现

在设计文档冻结之后，Vibe Agent 会将其拆解为一组标准化的任务说明书。

每一份任务说明书必须明确：

- 任务目标
- 任务范围（包含明确的禁止项）
- 允许的裁量空间
- 完成标准与验收条件

Coding Agent 在任务说明书定义的授权空间内执行实现：

- 在范围内拥有自由裁量权
- 对范围之外的内容保持必要的无知
- 达到验收标准后必须停止执行并返回结果

对全局的必要无知是该结构的核心保护机制。
如果 Coding Agent 拥有修改全局的权限，它就会在实现局部功能时，为了‘方便’而破坏全局一致性。任务说明书不仅是授权书，更是隔离墙。

Coding Agent的执行结果将交由一个独立的Audit Agent 进行验证。

Audit Agent 的职责被严格限定为：

- 验证实现是否符合任务说明书
- 判断是否存在越界行为
- 标注差异位置与失败原因

Audit Agent 不得引入新的实现或设计判断，也不得对代码进行修复。

---

### 递归结构与唯一回流路径

当审计失败时，只允许以下回流路径：

- 若任务说明不明确或自相矛盾，回流至设计阶段，由人类工程师修订文档
- 若任务明确但实现失败，回流至 Coding Agent 重新执行

不存在跨层修补或顺便修一下的路径。

整个流程以此方式递归推进。

---

## 四、解法的必然形态

基于以上推导，我们可以得到一种必然的解法形态：

- 人类工程师通过与 AI（Vibe Agent）的讨论完成高责任决策
- 决策被外显为设计文档并被冻结
- 设计文档被拆解为任务说明书，作为唯一执行授权
- AI（Coding Agent）在授权空间内执行实现
- 执行结果通过独立审计验证边界
- 所有失败仅能回流至其所属责任层级

这套解法被称为 Vibe + Coding。

它的核心转变在于：

把 Vibe Coding 变成 Vibe Writing + AI Coding。

- 在 Vibe 阶段，产出的是决策与约束，而不是代码
- 在 Coding 阶段，代码只是任务说明书被执行后的结果

在这一结构中：

- 人类工程师承担高责任判断，并对长期后果负责
- AI 在明确授权的空间内高效执行
- 决策与执行之间不存在反向污染路径

---

## 五、结论

Vibe + Coding 并不是一种更聪明的 AI 使用技巧，
而是一种在既定工程公理与现实约束下，被推导出来的协作结构。

它的目标不是让 AI 更强大，
而是确保：

高级决策永远只由能够承担后果的人做出，
且绝不被低级执行在实现阶段反向塑形。

# 第三章｜角色与心智模型：一场软件工程的战争

在前两章中，我们已经确立了 Vibe + Coding 的工程结构原则：

- 决策与责任不可分离
- 高责任决策必须由责任承担者完成
- AI 只能在被明确授权的责任空间内行动

但即便结构本身是正确的，工程仍然可能失败。
原因往往只有一个：

**人没有真正站到这个结构所要求的位置上。**

理解 Vibe + Coding 的关键，不在于学习“如何更好地使用 AI”，
而在于完成一次**角色认知上的根本转变**。

最有效的方式，是将一个软件工程项目，理解为一场**长期战争**。

---

## 3.1 一场战争，而不是一次对话

在 Vibe + Coding 中：

- 一个软件工程项目，是一场长期战争
- 每一次完整的设计—执行循环，是一场战役
- 每一次代码修改，是具体战术行动

战争的目标不是：

- 尽快写出代码
- 获得一次“看起来可用”的结果

而是：

**在长期对抗复杂性、不确定性与演化压力的过程中，持续维持系统结构与语义的稳定性。**

如果你仍然把 AI 编程理解为：

- 提问
- 回复
- 继续提问

那么你实际上是在用“聊天系统”的心智模型，
试图指挥一场战争。

结果几乎必然是指挥失序。

---

## 3.2 你的真实角色：最高指挥官，而非前线指挥

在这场战争中，你并不是：

- 工具的使用者
- prompt 的调试者
- 代码的直接执行者

你所处的位置是：

**最高指挥官**

这意味着，你负责的不是“怎么写代码”，
而是：

- 这场战争是否值得打
- 目标系统要解决什么问题
- 哪些复杂度是必须承受的
- 哪些风险是不可接受的

你真正承担的是：

**系统在未来数月乃至数年内的全部后果。**

因此，你的核心职责不是“给出更聪明的指令”，
而是：

- 明确战争目标
- 冻结不可逆决策
- 明确哪些问题不允许在执行阶段被重新讨论

如果战役失败，
责任不在执行单元，
而在于：

**战略层是否做出了清晰、可传递、可被约束的决心。**

同时，这个角色定位不随职务高低或任务大小而改变，它是天然递归的。

军长对旅长是最高指挥官，但他仍需服从集团军的战略；排长虽是连长的下属，但在他所守卫的那个小型阵地上，他就是唯一的、拥有最终裁断权的最高指挥。

在软件工程中也是如此：无论你是在重构整个支付中台，还是在优化一个字符串处理函数，只要你在该范围内承担后果，你就是该作用域内的最高指挥。权力与责任在任何尺度下都是对等的。

---

## 3.3 Vibe Agent：参谋系统，而非指挥系统

Vibe Agent 在这场战争中的角色是：

**军事参谋部（Staff / General Staff）**

它的职责是：

- 分析问题
- 推演方案
- 揭示隐含假设
- 比较不同决策路径的后果

它的作用是增强你的判断能力，
而不是替代你的判断责任。

因此它永远不拥有：

- 决策权
- 授权权
- 风险接受权

参谋部可以提出十种方案，
但哪怕只采纳其中一句话，
责任依然完全属于指挥官本人。

一旦你在心理上把“判断是否正确”外包给 Vibe Agent，
就等同于让参谋部自行发起战争。

在任何真实军事系统中，这都是结构性灾难。

---

## 3.4 设计文档：战役决心说明书（Commander’s Intent）

在真实战争中，最高指挥官不会通过无穷无尽的命令控制所有部队。

他会发布一份：

**战役决心说明书（Commander’s Intent）**

它明确的不是“如何执行”，
而是：

- 战役的目标状态
- 不可被违背的原则
- 已知风险与接受边界

在 Vibe + Coding 中，设计文档正承担这一角色。

它描述的是：

**当这一轮战役结束时，系统应该呈现出的结构与语义状态。**

这也是为什么：

- 设计文档属于高责任工件
- 必须被冻结
- 必须成为后续一切判断的唯一上位依据

一旦战役决心被冻结，
任何执行单元都无权重新解释战争目标。

---

## 3.5 参谋系统的第二项职责：从战役决心到可执行任务

在真实军事体系中，参谋部的职责并不止于“提出建议”。

当战役决心已经明确并被冻结之后，
参谋系统还必须承担一项关键职责：

**将指挥官的战役意图，转译为可被执行系统理解的任务结构。**

这一步不是决策本身，
而是决策的工程化表达。

在战争中，这通常表现为：

- 作战计划草案
- 阶段性行动划分
- 单位职责与边界说明
- 协同接口与依赖关系

这些内容全部由参谋系统起草，
但在任何情况下都不构成命令，
直到被指挥官正式批准。

---

## 在 Vibe + Coding 中的对应关系

在 Vibe + Coding 中，这一职责由 Vibe Agent 承担。

它的工作不是直接向 Coding Agent 下达指令，
而是：

**将已冻结的设计文档，拆解为一组清晰、可执行、互不越权的任务说明书草案。**

这些任务说明书用于明确：

- 本次任务解决什么问题
- 不解决什么问题
- 哪些设计结论已经冻结
- 哪些判断仍允许在执行层自由选择

其核心目的只有一个：

**防止战术执行阶段，被迫重新思考战略问题。**

---

## 一个关键原则：参谋只负责可执行性，不负责正确性

Vibe Agent 在拆解任务时关注的不是：

- 战役决心是否正确

而是：

- 是否足够清晰
- 是否存在歧义
- 是否能够被安全地下放

如果发现问题，参谋系统不应擅自修正决心，
而应将问题上推回指挥层，等待新的明确授权。

参谋部不修正战略，
只暴露战略的不完整性。

---

## 3.6 任务说明书：正式的行动授权文件

在 Vibe + Coding 中：

- 设计文档是战役决心说明书
- 任务说明书是经参谋系统整理后的正式授权

它明确界定：

- 允许发生什么
- 不允许发生什么
- 何时视为完成

Coding Agent 接收到的不是“你的想法”，
而是一份可审计、可回溯、不可随意解释的执行授权。

---

## 3.7 Coding Agent：受约束的战术指挥官

Coding Agent 是被授权的战术指挥官。

它可以：

- 决定具体实现路径
- 处理技术细节
- 在局部范围内做判断

但它绝不能：

- 修改战役目标
- 重新解释设计语义
- 扩大战役范围
- 引入未经授权的结构变化

一旦你期待 Coding Agent
“顺手帮你想一想战略是否要调整”，

这在军事意义上等同于：

**让前线指挥官自行决定战争走向。**

---

## 3.8 Verification / Audit：军纪与责任回溯系统

任何长期战争都不能依赖自觉。

因此必须存在：

**Verification / Audit Agent —— 军纪系统。**

它不判断是否聪明，
只判断是否越权。

审计的最高依据永远是设计文档。

---

## 3.9 越界的真正含义

越界不是犯错。

越界是：

**责任层级被跨越。**

当越界发生，问题不在代码，
而在于高责任决策未被正确冻结或被错误地下放。

---

## 3.10 指挥链的唯一方向

你（战略指挥官）
↓
战役决心（设计文档）
↓
参谋拆解（Vibe Agent）
↓
行动授权（任务说明书）
↓
战术执行（代码）

责任只能自上而下授权，
问题只能自下而上回溯。

---

## 3.11 新时代 AI 协作范式的本质

在新的 AI 工程范式下，我们真正需要的并不是：

- 能替你做决定的 AI
- 能替你发起战役的 AI
- 能“看起来很聪明”的全能代理

我们真正需要的是：

- **越来越聪明、越来越善于分析与拆解的参谋系统**
- **在执行阶段高度克制、严格遵守授权边界的一根筋前线指挥**

参谋可以极度聪明，
可以提出无数可能性，
可以不断挑战你的认知边界。

但一旦决心被冻结、命令下达：

**执行系统必须愚钝、克制、忠诚。**

它不思考战略是否更优，
不判断目标是否值得，
不因为“看起来更好”而擅自升级战事。

在任何高可靠系统中：

**聪明必须集中在决策之前，
而执行必须发生在决策之后。**

这正是 Vibe + Coding 所试图恢复的工程秩序。

---

## 3.12 本章小结

在 Vibe + Coding 中：

- 软件工程是一场长期战争
- 你是唯一的战略指挥官
- Vibe Agent 是越来越聪明的参谋系统
- Coding Agent 是执行阶段一根筋的战术指挥官
- 设计文档是战役决心
- 任务说明书是正式授权
- 审计系统负责军纪与责任回溯

当你真正站在这个位置上时，
你不再期待 AI 替你“想清楚一切”，

而是：

**在一个被严格约束的体系中，指挥智能为你服务。**


# 第四章｜Vibe + Coding 的最佳工程流程

本章给出 Vibe + Coding 的最佳**工程流程定义**。

这一流程并不是一个“如何使用 AI 的技巧集合”，
而是一套**以责任为核心、以文档为接口、以审计为约束的工程流程模型**。

它回答的不是“AI 能做什么”，
而是：

> **在一个需要长期维护的工程中，
> 不同智能体应当如何在被严格约束的前提下协作，
> 并且如何确保决策权、执行权与责任始终不发生错位。**

在前一章中，我们已经通过军事指挥系统建立了统一的心智模型。
本章将严格以**工程语言**描述流程本体，并在关键结构节点处，通过明确标识的
**「心智模型比喻」**，使用军事指挥系统对同一结构进行对照性重描写，
以解释这些工程约束为何不可被削弱或绕过。

---

## 一、流程的基本单元：一次责任闭环

在 Vibe + Coding 中，流程的基本单元**不是整个项目**，
而是一次**在明确责任边界内完成的工程闭环**。

一次工程闭环可以对应：

- 一个功能模块
- 一个子系统
- 一个阶段性目标
- 或一个可独立交付的责任单元

因此，本章描述的流程并不意味着“项目完成”，
而是意味着：

> **在当前责任范围内，
> 完成了一次合法的决策、分解、执行与审计，并由责任人回收结果。**

工程规模正是通过**多次责任闭环的递归组合**逐步扩展的。

---

### 心智模型比喻｜责任闭环

在军事指挥系统中，可被严格控制的最小单位不是“整场战争”，
而是一次被明确授权、目标清晰、可以被复盘的作战行动。
每一次行动都有明确的指挥官、参谋支持、执行单位与军纪约束，
并且在行动结束后，必须由指挥层确认结果并承担后果。
如果没有这样的行动闭环，任何指挥系统都会迅速失控。

---

## 二、流程总览：四个不可混淆的阶段

Vibe + Coding 的工程流程被明确划分为四个阶段：

1. **决策阶段**
2. **分解阶段**
3. **执行阶段**
4. **审计阶段**

这四个阶段不是简单的顺序步骤，
而是**责任密度逐级递减、但约束强度逐级增强的工程分区**。

每一个阶段都严格限定了：

- 参与角色
- 合法输入与输出
- 允许发生的行为
- 明确禁止的越权行为

---

## 三、决策阶段：高责任决策的唯一合法发生地

### 阶段目标

将模糊、不完整的需求与目标，
转化为**明确、可冻结、可被后续阶段执行与审计的设计决策**。

### 参与角色

- **Actor（人类工程师）**：唯一的责任承担者与决策确认者
- **Vibe Agent**：参与分析、推演与表达的协作者，不拥有决策权

### 输入

- 模糊需求描述
- 问题背景与约束
- 业务或技术目标

### 核心活动

在这一阶段，Actor 在 Vibe Agent 的辅助下完成：

- 明确要解决的问题与明确不解决的问题
- 界定系统或模块的责任边界
- 比较候选方案并完成取舍
- 明确必须长期成立的不变量
- 判断哪些风险可以接受，哪些必须避免

需要强调的是：

> **任何会对系统长期形态、语义边界或维护成本产生影响的判断，
> 都必须在此阶段完成并被显式确认。**

### 输出

- 一份完整、明确并被冻结的设计文档

从这一刻开始，设计文档进入只读状态，
后续阶段不再允许引入新的高责任判断。

---

### 心智模型比喻｜设计决策与指挥意图

在军事系统中，最高指挥官必须在行动开始前明确作战决心，
包括行动目标、允许付出的代价以及绝不可触碰的边界。
参谋部可以提出多种方案、分析风险、暴露假设，
但是否采纳、采纳到什么程度，只能由指挥官决定。
一旦作战决心形成，任何前线单位都无权重新讨论“要不要打”或“打到哪里”。

---

## 四、分解阶段：从决策到可执行任务

### 阶段目标

将已冻结的设计决策，
转化为**可以被执行体直接理解和执行的具体任务描述**。

### 参与角色

- **Vibe Agent**：主要负责分解与结构化表达
- **Actor（人类工程师）**：负责确认分解结果是否忠实反映原始决策

### 输入

- 已冻结的设计文档

### 核心活动

在这一阶段，Vibe Agent 将设计文档拆解为
**一份或多份任务说明书**。

每一份任务说明书都必须明确回答：

- 本次任务具体要完成什么
- 哪些设计结论已经冻结，不得触碰
- 哪些判断被明确下放给执行阶段
- 如何客观判断任务是否完成

---

### 心智模型比喻｜参谋部与作战命令

在军事系统中，指挥官并不会直接向前线下达模糊意图，
而是通过参谋部将作战决心转化为结构化的作战命令。
这些命令明确规定了任务目标、行动范围、禁止事项，
并且清楚写明“在什么状态下任务被视为完成”。
没有被清晰转译为命令的决心，在前线等同于不存在。

---

### 任务说明书的工程地位

任务说明书是一个**正式工程工件**，而不是临时提示或随意指令。

每一份任务说明书必须包含：

- 明确的任务目标
- 清晰的授权边界与禁止事项
- 可自由选择的技术空间
- **任务完成的判定条件（测试）**

---

### 心智模型比喻｜任务命令与完成条件

在作战命令中，胜负判据不是事后讨论的问题，
而是命令本身的一部分。
如果命令没有明确写明“达到什么状态即可结束行动”，
那么行动既无法执行，也无法评估，更无法追责。
测试在工程中的地位，正等同于作战命令中的完成条件。

---

## 五、执行阶段：在授权范围内完成实现

### 阶段目标

在不引入任何新决策的前提下，
完成任务说明书所描述的实现目标。

### 参与角色

- **Code Agent**：唯一执行主体
- 人类工程师：不参与

### 输入

- 单一任务说明书

### 核心活动

Code Agent 根据任务说明书：

- 选择具体实现路径
- 填补实现细节
- 调整实现以满足任务完成判定条件

执行阶段允许技术层面的自由选择，
但严格禁止任何形式的重新决策。

---

### 心智模型比喻｜前线执行与越权

在军事系统中，前线指挥官可以根据地形与态势选择进攻路线，
但无权改变作战目标或自行扩大行动规模。
任何“看起来更合理”的临时决策，
如果超出了命令授权，都会被视为越权行为。
执行阶段的一根筋，并非能力不足，而是体系稳定的前提。

---

## 六、审计阶段：一致性检查与责任回溯

### 阶段目标

判断执行结果是否**在合法授权范围内完成**，
并明确问题（若存在）的责任归属。

### 参与角色

- **Verification Agent**：执行审计
- **Actor（人类工程师）**：最终裁决

### 输入

- 执行结果
- 任务说明书
- 原始设计文档

### 核心活动

审计阶段不评判实现是否优雅，
只回答以下问题：

- 是否满足任务完成判定条件
- 是否违反任务说明书的授权边界
- 是否隐式改变了原始设计决策

需要明确指出的是：测试负责正确性，而审计负责合规性。

---

### 心智模型比喻｜军纪系统与责任回溯

在军事体系中，军纪系统不负责指挥作战，
也不负责优化战术，
它只做一件事：判断是否违令。
一旦发现越权行为，问题必须被上推至指挥层，
由作出决策的人承担修正或接受后果的责任。

---

## 七、责任回收与发布

审计完成后，流程进入责任回收点。

只有 Actor，作为责任承担者，
才拥有最终确认与发布权。

发布表示：

> **在当前责任边界内，一次工程闭环已经完成。**

发布结果可以作为后续流程的稳定前提。

---

## 八、递归结构：流程如何扩展为工程规模

Vibe + Coding 的工程流程是**天然递归的**：

- 上一轮流程冻结的决策
  → 成为下一轮流程的输入约束
- 下一轮流程的发布结果
  → 成为更高层系统中的既定事实

---

## 本章小结

Vibe + Coding 的工程流程是一套**以四阶段为核心的责任闭环模型**：

- 决策集中发生
- 分解负责去歧义
- 执行严格受限
- 审计明确归责

通过在关键结构节点引入清晰的**心智模型比喻**，
我们并非在“美化”流程，
而是在说明：
**这些工程约束并非人为选择，而是所有高可靠系统长期演化后的必然结果。**

# 第五章｜决策阶段（Decision Phase）

## 高责任判断的唯一合法发生地

在 Vibe + Coding 的工程流程中，**决策阶段是唯一允许高责任判断发生的阶段**。

本章不讨论整体流程，也不再解释角色关系；
这些内容已在前述章节中被明确冻结。

本章只回答一个问题：

> 在一个需要长期维护、可审计、可递归扩展的工程中，
> 所有会影响系统长期形态、语义边界与维护成本的判断，
> 应当如何被合法地产生、显式化并冻结？

---

## 一、决策阶段的工程地位

决策阶段不是“先想一想”，
也不是“实现之前的准备”。

它是一项**制度化的工程活动**，其工程目标高度明确且不可替代：

> 将所有高责任判断，
> 在可讨论、可回溯的状态下完成，
> 并将其冻结为后续分解、执行与审计的唯一合法依据。

在这一阶段完成的，不是“最优解”，而是：

- 问题边界的确认
- 系统责任的划定
- 候选方案的取舍记录
- 不变量与约束的明确声明
- 风险与代价的知情接受

一旦这些判断被冻结，
后续阶段不得重新讨论其正当性，**只能选择是否遵守**。

---

### 心智模型比喻｜作战决心的形成

在军事指挥系统中，
最高指挥层必须在行动开始前明确作战决心：

- 要达成什么目标
- 允许付出多大代价
- 哪些边界绝不可触碰

参谋系统可以提供分析、方案与推演，
但是否采纳、采纳到什么程度，只能由指挥官决定。

一旦作战决心形成，
任何前线单位都无权重新讨论“是否该打”或“打到哪里”。

工程中的决策阶段，正对应这一位置。

---

## 二、一个基本前提：决策阶段不通过实现生成决策

在决策阶段中，**允许并且经常必须引入工程约束**，包括但不限于：

- 性能目标
- 可实现性要求
- 资源与成本限制

例如：

- “该系统必须在指定吞吐量下稳定运行”
- “该模块若无法满足实时性要求，则整体方案不可接受”

这些约束**本身就是高责任决策的一部分**，
并且必须在决策阶段被**显式提出、讨论并冻结**。

---

但在决策阶段中，**不允许通过实现过程本身来生成或固化高责任判断**，例如：

- 通过“先写一版看看效果”来决定系统结构
- 因某次 demo 的偶然成功，默认某条设计路径是合理的
- 在代码中隐式确立接口、边界或职责划分

问题不在于效率，
而在于**责任合法性**。

任何通过实现过程“自然形成”的判断，都会不可避免地引入：

- 未被显式讨论的结构性决定
- 难以回溯的取舍路径
- 无法被清楚追责的设计来源

一旦这些判断通过代码“偷偷发生”，
后续的冻结、授权与审计就会失去合法性基础。

---

### 特别澄清：允许的尝试行为与其工程地位

在实践中，决策阶段**允许进行一定形式的尝试活动**，包括：

- 用于验证某个工程前提是否成立的实验性代码
- 用于测量性能上限或瓶颈的探索性实现
- 与最终工程无直接依赖关系的支线验证任务

但前提是，Actor 在**心智模型上必须清楚地意识到**：

> 这些行为属于决策前的必要火力侦察，
> 而不是作战决心本身。

这类尝试具有明确的工程地位：

- 它们的结果只能作为讨论素材
- 它们本身不构成设计决策
- 它们不得被直接纳入长期工程结构

任何来自尝试的结论，
**都必须重新回到决策讨论中，被显式表达、评估并冻结**，
否则就不具备工程合法性。

---

### 心智模型比喻｜火力侦察与作战决心

在军事系统中，
火力侦察用于判断敌情与地形，
但它**不能替代作战决心**。

如果指挥官因为某次侦察行动“进展顺利”，
就默认改变了作战目标或推进路线，
那不是灵活，而是失控。

工程中的尝试行为，
只有在被明确纳入决策讨论并完成冻结之后，
才具备制度效力。

---

## 三、决策阶段的内部结构：四个不可跳跃的步骤

为了确保高责任判断在冻结前被充分显式化，
决策阶段必须通过一个固定的内部结构来组织：

**输入 → 对齐 → 细化 → 冻结**

这不是流程控制机制，
而是一个**责任显式化模型**。

在进入冻结之前，这四个步骤之间允许自由回退与重启；
一旦冻结完成，任何回退都必须显式打破冻结状态。

---

## 四、输入：明确讨论对象，而非提出解决方案

### 阶段目标

输入步骤的目标只有一个：

> 明确当前要被认真讨论的问题是什么。

输入可以是：

- 一个模糊想法
- 一个目标陈述
- 一个尚未成形的需求

在这一阶段：

- 不要求完整
- 不要求正确
- 不进行技术选型

唯一需要判断的是：

> 这个问题是否值得进入高责任设计讨论。

输入应当是**较为明确的叙述性内容**，
而不是把判断权直接交给 AI 的问题。

---

### 示例（示意）

合法输入示例：

- “我们需要一个可以长期维护的评估系统，用于比较不同 LLM 模型的性能。”
- “当前系统在扩展到多个数据源时会失控，需要重新定义边界。”

不合法输入示例：

- “用 Python 还是 Rust？”
- “我们要不要用某个具体框架？”

---

### 心智模型比喻｜明确作战议题

在军事系统中，
第一步不是讨论战术，而是明确：

> 这次会议到底是讨论进攻、撤退，还是补给。

如果连讨论对象都不清楚，
后续任何推演都只是噪声。

---

## 五、对齐：消除问题定义中的歧义

### 阶段目标

对齐步骤的目标是：

> 确保 Actor 与协作智能体
> 对“正在解决的是什么问题”达成一致理解。

这一阶段不产生设计方案，
只产出一个**被明确写下的问题定义**。

---

### 合法行为

- 要求协作智能体复述问题理解
- 主动暴露隐含假设
- 明确目标、边界与非目标

---

### 示例（示意）

对齐阶段的合法提问方式：

- “请你复述你理解的系统目标与明确不解决的问题。”
- “请你以工程师的角度描述我的目标是什么。”

对齐完成的标志不是“听起来差不多”，
而是**问题定义已被明确写下，并由 Actor 确认认可**。

---

### 心智模型比喻｜统一作战语言

在作战会议中，如果不同部门对“主攻方向”理解不同，
那么再精妙的战术讨论都毫无意义。

对齐阶段的价值，正在于**提前消灭这种歧义**。

---

## 六、细化：构建可承担责任的系统结构

### 阶段目标

细化步骤的目标是：

> 在已对齐的问题定义之上，
> 将模糊问题转化为执行的结构性基础，
> 并在本阶段结束时，明确给出一个**可承担责任的可行方案**。

这里的“可行方案”并不指具体实现路径，
而是指一个在责任、边界与授权上已经闭合的系统结构。

在这一阶段，Vibe Agent 是主要的辅助角色：
提出参考方案、暴露风险、补充漏洞、挑战假设，
但所有关键判断必须由 Actor 明确完成。

---

### 合法活动

- 模块与职责边界划分
- 候选方案比较
- 不变量与约束提取
- 接口与数据形态的初步定义

协作智能体可以提出多个方案，
但**所有判断必须由 Actor 明确完成并承担责任**。

---

### 示例（示意）

合法细化输入示例：

- “你认为这个问题隐含了哪些前提？哪些如果错误会导致整体失败？”

合法细化输出示例：

- “系统必须严格区分输入、评估核心与输出。”
- “该接口仅接受 POST 方法，不接受 GET。”

不合法细化行为：

- “先写一版看看结构合不合理。”
  —— 将 demo 引入长期工程，这是战术侦察，不是作战决心。
- “实现过程中再决定这些边界。”
  —— 指令模糊，要么明确排除在本次讨论之外，要么现在定义清楚，否则即构成越权授权。

---

### 心智模型比喻｜参谋方案与指挥责任

参谋部可以提出多种作战方案，
但一旦发生失败，
承担责任的永远是作出选择的指挥官。

工程中的细化阶段，
正是责任显式落点逐步形成的过程。

---

## 七、冻结：形成唯一合法的设计依据

冻结是决策阶段中**唯一具有制度效力的节点**。

在这一节点，Actor 必须显式完成：

- 对设计结论的确认
- 对取舍与排除项的接受
- 对风险与限制的知情认可

冻结的形式可以是：

- 设计文档
- 架构说明
- 明确的不变量声明

形式不重要，语义才重要：

- 哪些判断已被接受
- 哪些取舍不再讨论
- 后续所有行为必须以此为准

冻结结果将作为：

> 分解、执行与审计阶段
> 判断“是否越界”的唯一合法依据。

---

### 心智模型比喻｜作战命令的签发

在军事系统中，
作战命令一旦签发，就具备制度效力。

任何“现场看起来更合理”的临时判断，
如果超出命令授权，
都构成越权。

---

## 八、冻结与回退：唯一合法的修改路径

冻结并不意味着“永不修改”。

但任何修改都必须满足以下条件：

1. 显式打破冻结状态
2. 回到决策阶段
3. 更新文档与约束
4. 重新完成冻结

不存在通过修改代码或调整实现细节
来绕过冻结的合法路径。

---

## 本章小结

决策阶段不是灵感阶段，也不是实现前的热身。

它是：

- 高责任判断的唯一合法发生地
- 后续分解、执行与审计的语义源头
- 工程中“可被递归引用事实”的生成点

当决策阶段被严格执行时：

- 后续任务才能被安全地下放
- 执行阶段才能被严格约束
- 审计阶段才能进行有效归责

**这正是决策阶段在 Vibe + Coding 中不可被削弱的工程意义。**

# 第六章 | 分解阶段（Decomposition Phase）

## 从已冻结决策到可执行任务的唯一合法路径

在 Vibe + Coding 的工程流程中，**分解阶段是决策与执行之间唯一允许存在的过渡区**。

如果说决策阶段解决的是：

> **“我们已经决定了什么，且不再讨论什么”**

那么分解阶段只解决一个问题：

> **如何在不引入任何新高责任判断的前提下，
把已冻结的设计决策，转化为可以被执行体直接理解和执行的任务描述。**

分解阶段不是设计阶段的延续，
也不是执行阶段的开始。

它是一项**翻译工作**，而不是判断工作。

---

## 一、分解阶段的工程地位

分解阶段的核心工程目标可以被精确定义为：

> **将已冻结的高责任设计结论，
转译为结构化、无歧义、可审计的任务说明书，
并明确哪些判断已经完成，哪些判断被授权给后续执行阶段。**

在这一阶段中：

- **不得**重新讨论设计是否合理
- **不得**补充新的系统级判断
- **不得**通过“顺手决定”引入新的责任来源

分解阶段的失败，往往不是因为执行能力不足，
而是因为**设计判断在这里被悄悄重写**。

---

### 心智模型比喻｜作战决心到作战命令

在军事系统中，
作战决心本身并不能被前线单位直接执行。

它必须被转译为**结构化、可验证的作战命令**：

- 明确任务目标
- 明确行动范围
- 明确禁止事项
- 明确完成条件

如果这一步缺失，
那么所谓的“执行灵活性”，只会演变成越权。

分解阶段，正对应这一角色。

---

## 二、分解阶段的参与角色与责任划分

### 参与角色

- **Vibe Agent**
  分解阶段的主要执行者，负责结构化表达与任务拆解。

- **Actor（人类工程师）**
  分解结果的最终确认者，负责判断分解是否**忠实反映原始决策**。

---

### 责任边界

在分解阶段：

- Vibe Agent **可以决定表达方式**
- Vibe Agent **不能决定设计含义**
- Actor **不再做设计选择**
- Actor **只判断是否发生了语义偏移**

换句话说：

> 分解阶段允许“怎么说”，
> 但不允许“说了什么不一样”。

---

## 三、分解阶段的输入与输出

### 合法输入

分解阶段只接受一种合法输入：

- **已被冻结的设计决策产物**

包括但不限于：

- 设计文档
- 架构说明
- 不变量与约束声明

如果输入本身仍然存在歧义，
那说明问题应当被退回至**决策阶段**，而不是在此阶段补救。

---

### 合法输出

分解阶段的输出是一个或多个**任务说明书**。

每一份任务说明书都必须满足：

- 可被独立理解
- 可被独立执行
- 可被独立审计

它不是提示词，也不是临时指令，
而是一个**正式工程工件**。

---

## 四、任务说明书的工程定义

在 Vibe + Coding 中，任务说明书不是执行指令，也不是实现提示，
而是一种**用于界定执行阶段责任边界的工程工件**。

它的核心作用只有一个：

**在不引入任何新判断的前提下，
一次性明确执行阶段：要达成什么、谁说了算、哪些不能动、允许如何做、何时算完成。**

为了避免任务说明书退化为 checklist 或临时指令，
需要从工程角度明确：
**一份合格的任务说明书，必须同时覆盖以下五个方向的约束。**

这些方向不存在先后顺序，
它们共同构成执行阶段的合法行动空间。

---

### 4.1 目标与意图（本次任务要完成什么）

这一部分用于明确：
**当任务完成时，系统相对于任务开始前应当发生的状态变化。**

它关注的是“完成后的世界长什么样”，
而不是“中间应该怎么做”。

在这一方向中，任务说明书应当明确：

- 本次任务的核心目标
- 本次变更试图解决的具体问题
- 成功完成后应当满足的整体状态

这一部分通常**保留实现自由度**。
只要最终状态满足目标，
执行体可以在不违反其他约束的前提下自行选择实现路径。

**心智模型比喻：**
这相当于作战中的**作战目标**——
例如“坚守阵地”或“夺取高地”，
它定义的是行动的方向，而不是完成的终点。

---

### 4.2 权威与裁决（当出现冲突时，谁说了算）

这一部分用于明确：
**当不同信息来源之间出现不一致时，最终裁决权属于哪里。**

在复杂工程中，
文档、测试、现有实现、历史经验往往并不完全一致。
如果任务说明书未明确裁决来源，
执行阶段就会被迫自行“选择相信谁”，
从而无意中承担设计责任。

在这一方向中，任务说明书应当明确：

- 哪些文档或规范具有最高权威
- 其他材料在本次任务中的地位
- 当冲突发生时应当遵循的裁决顺序

这一部分的目的，是**阻断执行阶段通过选择性解释重新引入设计判断的可能性**。

**心智模型比喻：**
这相当于作战中的**战役目标与指挥权归属**——
一旦确定，前线单位无权自行改变行动方向。

---

### 4.3 边界与冻结（哪些工程事实不得触碰）

这一部分用于明确：
**在本次任务中，哪些工程判断已经完成，不属于执行阶段的裁量范围。**

它关注的不是“系统现在长什么样”，
而是“哪些东西在本次任务中被明确冻结”。

在这一方向中，任务说明书通常会冻结：

- 允许或禁止修改的范围
- 已确定的结构性设计与模块职责
- 不变量、接口语义或其他硬约束
- 明确排除在本次任务之外的内容

如果这一部分缺失，
执行体往往会在“让事情更好实现”的名义下，
对既有决策进行实质性修改。

**心智模型比喻：**
这相当于作战中的**战略边界与禁区**——
前线可以机动，但无权改变战区范围或防线位置。

---

### 4.4 执行约束与工作方式（允许如何工作）

这一部分用于明确：
**执行阶段在工程层面被允许采用的工作方式与作战形式。**

它并不指导具体操作步骤，
而是限制执行阶段的自由度，
以防止引入隐性复杂度或不可审计的差异。

在这一方向中，任务说明书通常会约束：

- 允许或要求使用的工具与运行方式
- 既定的开发方法与工作纪律
- 工程规范、代码质量与组织规则
- 工件（代码、测试、文档）的放置原则

这些约束并不决定“打哪里”，
而是决定“**以什么形式打**”。

**心智模型比喻：**
这相当于作战中的**作战形式选择与战术手段约束**——
明确这场仗是使用装甲推进、空降突袭，还是阵地防御；
但并不决定具体从哪条路线推进、由哪支部队先行。

一旦作战形式被确定，
就不得在执行过程中随意切换。

---

### 4.5 验收与完成语义（什么时候算完成）

这一部分用于回答一个不可回避的问题：
**在工程意义上，如何判断本次任务已经完成。**

如果任务说明书无法明确完成判据，
那么执行阶段无法自主结束工作，
审计阶段也无法判断是否发生越权。

在这一方向中，任务说明书应当明确：

- 必须满足的功能语义与行为约束
- 明确禁止出现的行为
- 成功与失败的可观察表现
- 可被验证的完成条件
- 必要的审计与总结工件

**目标与完成判据是两个不同层级的概念。**

**心智模型比喻：**
作战目标可能是：
“坚守阵地”；

但完成判据必须进一步明确：
“坚守阵地直到晚上 10 点，且防线未被突破”。

前者定义**要做什么**，
后者定义**做到什么程度才算合格、可以结束行动**。

如果没有完成判据，
行动就无法结束，
责任也无法被追溯。

---

### 一个重要提醒

上述五个方向并不是书写顺序，
也不是独立存在的条目。

它们共同定义了：

**执行阶段被授权的行动空间，以及不可逾越的责任边界。**

只要其中任何一个方向缺失，
任务说明书在工程上就是不完整的。

---

### 本节小结

任务说明书的价值，
不在于写得是否详细，
而在于是否一次性解决了执行阶段本不应再思考的问题。

当目标清晰、权威明确、边界冻结、作战形式受控、完成判据可验时，
执行阶段才能被安全地外包，
而不必担心设计在实现过程中被悄然改写。


---

## 五、分解阶段的合格判据

一个分解结果是否合格，可以用一个非常严格的工程标准来判断：

> **如果将任务说明书交给一个完全未参与前序讨论的执行体，
它是否可以在不再询问设计性问题的前提下开始工作？**

允许执行体提出的问题包括：

- 实现细节上的澄清
- 技术层面的选择空间

但**不允许**出现的问题包括：

- “这个模块是不是也应该负责 X？”
- “这个边界是你已经决定好的，还是我可以改？”
- “这个设计是现在确定的，还是实现时再看？”

一旦出现这些问题，
说明分解阶段**未能完成其工程职责**。

用更简单的语言来说就是，如果一个actor作为一个人类工程师拿到这个任务说明书，他是否能够成功在不越界地前提下完成这个任务。

---

## 六、常见错误：在分解阶段重新设计

分解阶段最常见、也最危险的错误，是：

> **以“让任务更好执行”为名，
重新引入设计判断。**

典型表现包括：

- 在任务说明书中补充新的设计假设
- 为了“方便实现”弱化原始约束
- 在未回到决策阶段的情况下修改接口含义

这些行为在形式上看似合理，
但在工程责任上**完全不可接受**。

---

### 心智模型比喻｜前线改写作战命令

前线指挥官可以选择进攻路线，
但无权修改作战目标。

任何以“现场情况更合适”为理由，
对命令本身进行修改的行为，
在军事系统中都被视为严重违纪。

---

## 七、分解与回退：唯一合法的修正方式

如果在分解过程中发现：

- 原始设计存在歧义
- 决策结论不足以支撑任务定义

**唯一合法的处理方式是：**

1. 中止当前分解工作
2. 将问题显式上推
3. 回到决策阶段补充或修正设计
4. 重新冻结后，再次进入分解

不存在在分解阶段“临时修补设计”的合法路径。

---

## 本章小结

分解阶段不是思考阶段，
也不是执行阶段的前奏。

它是：

- 决策与执行之间的**责任隔离层**
- 防止设计被悄然篡改的**结构缓冲区**
- 执行阶段合法性的**唯一来源之一**

当分解阶段被严格执行时：

- 执行阶段可以被安全地完全外包
- 决策阶段的结论不会被实现过程侵蚀
- 审计阶段才能清晰判断是否越权

**这正是分解阶段在 Vibe + Coding 中不可被跳过的工程意义。**

# 第七章｜执行阶段（Execution Phase）

## 在既定授权下，消耗冻结语义

在分解阶段结束后，工程系统已经具备一个关键前提：

**执行阶段所需的一切高责任判断，已经完成并被冻结。**

执行阶段不再关心：
- 设计是否合理
- 决策是否最优
- 目标是否应该调整

它只关心一件事：

**如何在不突破授权边界的前提下，
将既定语义转化为可验证的工程现实。**

执行阶段不是设计的延续，
也不是决策的补充。

它是一段**受限、可回溯、可被完全审计的语义消耗过程**。

请注意，在Vibe + Coding范式中，这里Coding Agent和Vibe Agent是两个不同的Agent，二者交流的唯一通路是文档：设计文档和任务说明。
这两者不强制要求是具体的隔离形式，可以是ChatGPT + Cursor，可以是Copilot里面的不同对话，但是一定不能共享上下文。
这种方式在物理上避免了设计阶段的噪声穿透无知之幕进入执行阶段。


---

## 一、执行阶段的工程地位

在 Vibe + Coding 中，执行阶段被严格定义为：

**在任务说明书所界定的授权空间内，
完成一次最小、原子、可验证的工程实现。**

在这一阶段中：

- 不再允许引入新的设计判断
- 不再允许重新解释冻结语义
- 不再允许以“实现更合理”为由修改既有边界

执行阶段的合法性，完全依赖于分解阶段的产物。
一旦执行体开始工作，即默认接受以下事实：

- 目标已经确定
- 权威已经指定
- 边界已经冻结
- 完成判据已经定义

执行阶段无权质疑这些前提。

---

### 心智模型比喻｜命令已下达，行动已授权

在军事系统中，
一旦作战命令下达并生效：

- 前线单位不再讨论战略是否正确
- 不再重新评估政治目标
- 不再自行调整作战目的

其唯一职责是：

**在命令所允许的范围内，
以最可靠的方式完成行动。**

执行阶段正处于这一位置。

---

## 二、执行阶段的唯一输入

执行阶段只接受一种合法输入：

**已确认、已冻结、可审计的任务说明书。**

执行体不得：

- 追溯设计阶段的讨论过程
- 依赖口头解释或隐含背景
- 根据历史实现自行补全语义

在执行阶段：

- 设计文档只作为被引用的权威来源
- 任务说明书是唯一直接约束执行行为的工件

任何不在任务说明书中明确授权的行为，
在工程语义上默认不被允许。

---

## 三、执行体的受限行动循环

在 Vibe + Coding 中，执行体（包括 Coding Agent）的工作被限制在一个明确、封闭的执行循环内：

1. 阅读并确认任务说明书
2. 根据任务说明书中定义的验收语义，准备验证工件（通常为测试）
3. 运行验证工件，确认其初始失败状态
4. 编写最小实现以满足约束
5. 重新运行验证
6. 修正实现，直至全部约束满足

在这一循环中，执行体：

- 可以选择具体实现路径
- 可以在允许的范围内进行技术取舍
- 可以调整代码组织以满足既定规范

但不允许：

- 修改设计文档
- 扩展任务范围
- 引入未声明的行为
- 进行结构性重构以“提升整体质量”

执行阶段的成功标准只有一个：

**实现行为完全满足任务说明书所定义的可验证约束。**

---

## 四、最小原则：面对文档灰区的唯一合法策略

即使分解阶段已经尽力消除歧义，
在真实工程中，执行体仍可能遇到任务说明书未明确覆盖的情况。

在执行阶段，这类情况被统称为：

**文档灰区。**

面对文档灰区，执行阶段不允许引入新的设计判断。
唯一合法的处理原则是：

**最小原则（Minimal Principle）。**

最小原则意味着：

- 不扩展既有语义
- 不引入新的长期承诺
- 不增加不可逆的结构复杂度
- 选择影响面最小、可替换、可回退的实现方式

最小原则不是聪明实现，
而是一种刻意克制的工程姿态。

---

### 心智模型比喻｜在边界处机动，而不是改写命令

前线部队在执行过程中，
**可以在不得已的情况下进入原命令未明确授权的区域**，
例如因天气、地形或环境变化，
原定阵地已无法部署或继续推进。

在这种情况下，
前线部队可以后退、绕行，或临时占据替代位置，
以维持行动的连续性并完成既定任务。

但这种行为必须同时满足以下前提：

- 该越界行为必须以完成既定任务为唯一目的
- 越界范围应当保持在影响面最小的程度
- 所有越界行为及其触发原因必须被完整记录在案，
  以供事后检查与责任裁决

最小原则所对应的，
正是这种**在行动不中断的前提下，
允许有限越界，但拒绝隐性扩权的受限机动**。

---

## 五、越界是一种现实，而不是例外

Vibe + Coding 并不假设执行阶段永远正确。

相反，它明确承认：

**执行体在文档灰区发生越界，是一种可预期的工程现实。**

因此，体系的安全性并不依赖于：

- 执行体足够谨慎
- Agent 足够聪明
- Prompt 足够完美

而依赖于一个更根本的事实：

**越界是否能够被识别，
以及是否存在明确的回流与裁决机制。**

执行阶段本身不负责裁决越界是否合法，
它只负责留下足够清晰的痕迹，
以供后续审计阶段判断。

---

## 六、实现报告：执行阶段必须留下的工件

每一次执行任务完成后，
执行体必须输出一份实现报告。

实现报告不是总结性文字，
而是一份可被审计的执行记录，至少应当说明：

- 本次实现覆盖了哪些任务目标
- 实现如何对应任务说明书中的约束
- 是否遇到文档灰区
- 是否做出了最小原则下的取舍

实现报告的存在，使得执行阶段：

- 不再是黑箱
- 不依赖执行者记忆
- 不因人员或 Agent 更替而丢失上下文

---

## 执行中止条件：一种实现层防御机制

*本节为实现层建议，不构成方法论成立的必要条件。*

在部分高风险或高度不确定的工程环境中，
可以为执行体引入一组执行中止条件，用于提前暴露问题。

典型的中止触发情形包括：

- 任务说明书中的约束在工程上相互冲突
- 多种实现路径均涉及明显的设计性取舍
- 验证工件无法表达关键冻结语义

当中止条件被触发时，执行体应当：

- 停止进一步实现
- 明确记录触发原因
- 将问题上抛，交由后续阶段处理

需要强调的是：

**执行中止并不是为了保护执行体，
而是为了避免在执行阶段隐式承担设计责任。**

---

## 七、执行阶段的结束条件

执行阶段的结束，并不以代码写完为标志。

它必须同时满足：

- 所有验证工件通过
- 实现报告已生成
- 所有执行行为可被回溯到任务说明书中的授权条目

一旦这些条件成立，
执行阶段即告结束，
系统将进入下一个阶段。

---

## 本章小结

执行阶段不是一个发挥创造力的空间，
而是一个受限行动、受控消耗、等待审计的阶段。

在这一阶段中：

- 决策已经完成
- 授权已经明确
- 行动被严格约束
- 越界被允许发生，但不得被掩盖

通过这种设计：

- 执行可以被安全地外包
- 设计主权始终掌握在人类工程师手中
- 工程系统能够在长期演化中保持结构稳定

**执行的价值，不在于聪明，
而在于可控。**
© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.2

---

# 第八章｜审计阶段（Audit Phase）

## 在执行结束之后，重新引入判断

在 Vibe + Coding 中，
**审计阶段是执行阶段之后，唯一被授权重新引入高责任判断的阶段。**

在进入审计阶段之前，有一个前提必须被明确：

> **执行已经结束，
> 执行体不再拥有任何行动权。**

审计阶段不再修改代码，
不再补充实现，
不再继续“把事情做完”。

它只做一件事：

**判断已经发生的执行行为，
是否落在既定授权边界之内。**

---

## 一、审计阶段的工程地位

审计阶段在工程流程中的位置是明确且不可替代的。

它不是执行阶段的延伸，
也不是下一个执行循环的开始，
而是一个**责任回收与边界校准的阶段**。

在这一阶段中：

- 判断权重新回到高责任角色
- 执行体的解释权被严格限制
- 结果的好坏不构成合法性的依据

审计阶段的核心问题不是：

“这样做对不对？”

而是：

> **“这样做，有没有被授权？”**

---

### 心智模型比喻｜战后评估，而不是现场指挥

### 心智模型比喻｜军纪审查，而不是战场指挥

在军事系统中，
战斗结束并不意味着一切自动合法。

真正决定行动是否被认可的，
不是前线的判断，
而是随后展开的**军纪与命令审查**。

在这一阶段：

- 不再下达新的作战命令
- 不再调整战术部署
- 不再讨论当时是否“更合理”

审查只基于三样东西：

- 既定的作战命令
- 事前明确的授权边界
- 战斗过程中留下的行动记录

评估的核心问题不是：

“如果当时换一种打法会不会更好？”

而是：

**“这些行动，是否在既定命令与授权之内发生？”**

审计阶段，正对应这一角色：
它不是继续指挥行动，
而是对行动是否遵守既定军纪与命令体系作出裁决。


---

## 二、审计阶段的唯一目标

审计阶段的目标可以被精确表述为：

> **基于既定的授权文档与执行记录，
> 对执行行为的合法性做出明确裁决。**

它不追求“工程最优解”，
也不负责“让系统变得更好”。

它只负责三件事：

- 确认哪些行为是合法的
- 识别哪些行为触及灰区
- 明确哪些行为构成越权

并为后续流程提供一个**清晰、不可歧义的裁决结果**。

---

## 三、审计输入工件：裁决的唯一事实基础

审计阶段并不“理解系统”，
也不“还原执行过程”。

它只做一件事：

**基于一组被明确允许的工程工件，
判断执行行为是否被授权。**

因此，在 Vibe + Coding 中，
**审计阶段的第一原则不是如何判断，
而是：哪些东西可以被用来判断。**

任何未被纳入审计输入工件范围的材料，
无论看起来多么合理、多么“有助于理解背景”，
在工程语义上都必须被视为不存在。

---

### 3.1 审计输入的冻结原则

审计阶段只接受执行阶段结束时已经存在的工件。

在审计过程中：

- 不允许补充新的解释性材料
- 不允许引入事后总结的“理解”
- 不允许根据结果反推执行意图

审计判断只基于当时已经留下的事实记录，
而非事后整理的叙述。

如果某个行为在执行阶段没有留下可被审计的痕迹，
那么它在审计语义中就是不可证明的。

---

### 3.2 核心审计输入工件清单

审计阶段必须、且只允许使用以下工件作为判断依据。

#### 3.2.1 冻结的设计文档

冻结的设计文档定义的是：

- 系统的语义边界
- 模块职责与不变量
- 已完成并冻结的高责任判断

在审计阶段：

- 设计文档是最高语义权威
- 用于判断某一类行为是否原则上被允许存在

审计不评估设计是否合理，
只评估设计是否被遵守。

---

#### 3.2.2 对应版本的任务说明书

任务说明书是执行阶段的直接授权书。

它定义的是：

- 本次任务被允许触碰的范围
- 明确冻结的工程事实
- 验收与完成的判据

在审计阶段，任务说明书用于判断：

- 某一具体行为是否被明确授权
- 某一取舍是否仍然落在授权空间之内

任何既未被授权、
也无法被归类为最小原则下必要取舍的行为，
都将被视为越权候选。

---

#### 3.2.3 实现代码与验证结果

实现代码与测试结果用于回答：

**执行体实际做了什么。**

它们不是权威来源，
也不具备裁决地位。

代码是否优雅、
测试是否全部通过，
本身不构成合法性的证明，
它们只是行为发生的证据。

---

#### 3.2.4 实现报告（Execution Report）

实现报告是执行阶段必须留下的解释性工件。

它用于：

- 标注实现行为与授权条目的对应关系
- 明确是否触及文档灰区
- 说明是否采用最小原则下的取舍

在审计阶段，
实现报告不是辩护词，
而是执行体对自身行为的结构化标注。

---

#### 3.2.5 执行阶段产生的记录与标注

包括但不限于：

- 灰区触发记录
- 执行中止标注
- 明确声明的越界行为及其原因

这些记录的价值不在于解释是否充分，
而在于是否承认并显式暴露了越界的发生。

未被记录的越界，
在审计语义中被视为隐性扩权。

---

### 3.3 明确排除的非审计输入

以下内容被明确禁止作为审计依据：

- 执行体的主观意图
- 口头或临时解释
- 结果导向的合理性辩护
- 事后补写的设计理解
- 未被冻结的草稿或中间文档

这些内容可能在工程上“有帮助”，
但在责任结构上不可接受。

---

### 3.4 输入工件不完整时的默认裁决立场

当审计输入工件存在缺失、模糊或无法对齐时，
审计阶段采取：

**不利于执行体的解释优先原则。**

这不是惩罚，
而是一种结构性约束，
用于鼓励在执行阶段留下充分痕迹，
并防止通过事后解释逃避裁决。

---

## 四、审计关注的裁决问题

审计阶段关注的不是任务是否完成，
而是以下问题：

- 执行行为是否落在授权边界内
- 是否存在灰区下的最小原则执行
- 是否存在未记录、未声明的隐性扩权

审计结论必须明确归类为：

- 合法执行
- 灰区但可接受
- 明确越权

不存在“暂时不处理”的合法状态。

---

## 五、裁决后的唯一合法处理路径

当审计发现问题时，只允许两种处理结果：

1. 收紧授权
   - 判定行为未被授权
   - 要求回退或重写实现

2. 显式放权
   - 确认行为可接受
   - 将原本隐含的自由度写入文档
   - 重新冻结授权边界

审计阶段不追责，
它只做定界。

---

### 心智模型比喻｜不是惩罚，而是修正边界

审计不是为了否定执行，
而是为了防止系统在无意识中扩权。

---

## 六、审计结果作为工程工件

审计阶段必须产出正式的审计结果工件，明确记录：

- 裁决结论
- 所依据的输入工件
- 是否触发文档修订
- 对后续流程的影响

审计结果将直接影响：

- 后续分解是否合法
- 是否需要回退执行
- 系统授权边界是否发生变化

---

## 本章小结

审计阶段不是为了让系统“更聪明”，
而是为了让系统**不失控**。

通过冻结审计输入、限制裁决依据、
强制越权显性化：

- 执行不再依赖信任
- 判断不再依赖记忆
- 系统演化不再依赖侥幸

**审计的力量，
来自于它拒绝理解一切未被记录的合理性。**
