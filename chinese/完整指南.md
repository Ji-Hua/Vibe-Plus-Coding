© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 引言｜Introduction

Vibe Coding 是一个非常好的工具。
作为一名长期从事系统设计与维护的工程师，我非常乐意使用任何能够降低实现劳动量的技术，而 AI 正是其中最具潜力的一种。

但在接近一年的实际使用过程中，我逐渐意识到一个问题：
**AI 并不能独立承担中大型系统的实现任务。**
甚至在稍微复杂一些的工程中，它也很容易出现结构失控、语义漂移和不可维护的问题。

这些问题往往并不体现在“代码能不能跑”，而体现在工程质量本身，例如：

- 编写与设计目标无关的代码
- 将本应通过参数或配置传递的内容硬编码进实现
- 随意加入无意义的日志、调试输出
- 函数接口定义混乱、职责不清
- 继承结构随意扩展，缺乏抽象边界
- 任意修改项目目录结构
- 无约束地安装依赖，引入隐性复杂度

我尝试过使用更复杂的 prompt、更严格的说明，甚至将 agent 行为一步步细化，但效果始终有限。
AI 在这种模式下，最多只能胜任简单、局部、低风险的功能实现；一旦任务复杂度上升，整个项目就会迅速失控。

真正的转折点，发生在一个看似普通的个人项目中。

当时我希望将一个桌游实现为 Web App。与以往不同的是，这一次我先写了规则说明书，然后基于规则设计了测试用例，再开始动手实现。
也正是在这一刻，我突然意识到：
**问题并不在于 AI 不够强，而在于我一直没有用对方式。**

作为一个写了十多年代码的工程师，我自己都无法保证每一行代码天然正确。
我同样需要说明文档来明确语义，需要测试来约束行为，需要结构来防止系统腐化。
那么，我凭什么要求 AI 在没有这些约束的情况下，独立完成复杂工程？

AI 的优势并不在于设计系统，而在于精确执行已经明确的决策。
而设计、取舍、权衡与责任归属，恰恰是人类工程师的核心价值所在。
换句话说，项目的所有权只能属于人类，决策也不应被外包给模型。

不同工程师写出的代码本就千差万别，AI 并无例外。

在意识到这一点之后，我开始有意识地调整工作方式：
先与 AI 共同完成设计文档，再冻结决策；
基于文档编写测试；
最后再让 AI 执行受约束的实现、运行、修复与重构。

我将这一模式应用在两个不同规模的项目中，结果都基本达到了我的工程预期。
至此，我确认：这并不是一次偶然的成功，而是一种可复用的工程范式。

我将这种工作方式命名为：**Vibe + Coding**。其中设计部分即Vibe，实现部分即Coding，二者通过文档进行交互。

本指南，正是对这一范式的系统性整理与总结。

# 第一章｜设计理念（Design Philosophy）

在引言中，我已经说明了 Vibe + Coding 并不是一次偶然的技巧发现，而是源自真实工程实践中的反复失败与修正。本章的目的，是进一步明确这一范式背后的**工程立场与设计假设**。

---

## 0. 什么是 Vibe + Coding（明确且可执行的定义）

**Vibe + Coding 并不是一种“更聪明的 Vibe Coding”，
而是将传统 Vibe Coding 强行拆分为两个彼此分离的阶段。**

这两个阶段分别是：

- **Vibe（设计阶段）**
- **Coding（实现阶段）**

二者的关系不是协作混合，而是**职责隔离**。

### Vibe 阶段（设计阶段）

Vibe 阶段只负责一件事：

> **将人类工程师的设计意图，转化为可执行的外部结构。**

具体产出包括但不限于：

- 设计文档（Design Doc）
- 架构说明
- API 文档
- 数据结构定义
- 任务说明书
- 行为约束描述
- 测试设计（或测试意图）

在这一阶段中：

- 不追求代码实现
- 不关心语法细节
- 不允许“顺手写点代码看看”

Vibe 阶段的唯一目标，是**冻结决策，并将其外显为文档结构**。

---

### Coding 阶段（实现阶段）

Coding 阶段同样只负责一件事：

> **严格依据已有文档与测试，完成受约束的实现。**

在这一阶段中：

- 不重新讨论设计
- 不引入新的隐式假设
- 不“优化一下结构”
- 不补充未经说明的行为

Coding 阶段的输入是文档，
输出是代码。

---

### 一个必须强调的关键约束：不共享上下文

**Vibe 与 Coding 不应该共享上下文。**

这不是“推荐做法”，而是**范式成立的必要条件**。

这意味着：

- Vibe 阶段产生的所有信息，必须通过文档传递
- Coding 阶段不依赖任何“之前聊过的内容”
- 除文档与测试之外，不存在隐式沟通渠道

在工具层面，这种隔离可以通过多种方式实现：

- 使用不同工具（例如 ChatGPT 负责 Vibe，Cursor / Copilot 负责 Coding）
- 使用同一工具的不同会话窗口（例如 Copilot Chat vs Copilot Agent）
- 使用不同 Agent 实例，禁止共享历史上下文

**只要上下文是共享的，Vibe + Coding 就会退化回旧的 Vibe Coding。**

---

### 一句话总结定义

> **Vibe + Coding =
> 将 Vibe Coding 强制拆分为“设计生成文档”与“按文档实现代码”两个阶段，
> 二者职责分离、上下文隔离，仅通过文档与测试进行通信。**

如果你无法做到这一点，那么你使用的仍然是旧的 Vibe Coding。

---

## 1. 两种完全不同的编程范式

### Vibe Coding（旧范式）

本文所说的 **Vibe Coding**，指的是当前最常见的一种 AI 编程方式：

- 在单一对话中与 AI 持续交互
- 设计、实现、调试混合进行
- AI 同时承担“理解问题”和“生成代码”的角色
- 工程连续性依赖上下文窗口的隐式记忆

这种方式在以下场景中是有效的：

- 原型验证
- 一次性脚本
- 小工具
- 探索性尝试

但在中大型工程中，它往往会系统性失效：

- 设计意图在对话中逐步漂移
- 实现细节反向主导结构
- 决策被埋入代码，不可追溯
- 出现问题时，难以解释“为什么会这样”

这不是使用者不够谨慎，也不是模型不够强，
而是这种模式**本身不具备工程级稳定性**。

除非特别说明，本文中的 “Vibe Coding” 一律指该旧范式。

---

### Vibe + Coding（新范式）

**Vibe + Coding 并不是 Vibe Coding 的加强版，
而是对其进行结构性拆分。**

它将原本混杂在一起的过程，强制拆分为两个阶段：

- **Vibe：设计阶段，负责生成文档**
- **Coding：实现阶段，负责按文档执行**

二者职责分离、上下文隔离，
仅通过文档与测试进行通信。

Vibe + Coding 关注的不是如何让 AI 更聪明，
而是：

- 谁负责思考
- 谁负责执行
- 决策如何被冻结
- 系统语义如何被保存

在这一范式中：

- 人类工程师始终是项目所有人，负责设计与取舍
- AI 不再参与设计判断
- 而是作为**受约束的执行角色**存在

只要这一分离被破坏，
流程就会不可避免地退化回旧的 Vibe Coding。

---

## 2. 这个范式真正要解决的问题

在现实的软件开发中，工程师的大量精力往往并未消耗在真正困难的地方。

相反，时间常常被以下工作吞噬：

- 胶水代码
- 重复结构
- 模板式逻辑
- 框架约束下的样板实现
- 与核心设计无关的工程噪音

这些工作并不复杂，却持续消耗注意力。

与此同时，真正决定系统质量与寿命的部分——

- 架构设计
- 抽象建模
- 接口边界
- 不变量定义
- 长期可维护性判断

却只能在零散时间中被仓促完成。

Vibe + Coding 并不是为了“让一个人写更多代码”，
而是为了回答一个更现实的问题：

> **如何让工程师把有限的认知资源，用在真正不可替代的地方。**

因此，它追求的也不是“效率最大化”，
而是：

> **工程责任的完整性。**

### 没有万能药

**Vibe + Coding 的目标，从来不是让编程变得轻松。**

编程本身就不是一项轻松的工作。
任何试图将复杂工程描述为“只要提示词写得好就能完成”“AI 可以自动搞定一切”的叙事，本质上都是对工程现实的误判。

Vibe + Coding 并不试图减少思考量，
它真正做的事情只有一件：

> **重新分配思考发生的位置、形式与责任。**

---

## 3. 一个必须正视的现实：上下文是脆弱的

在当前阶段，所有大模型都存在一个无法回避的限制：

**上下文窗口是有限且不稳定的。**

当任务规模扩大时，这一限制会系统性地暴露出来：

- 早期设计决策逐渐被遗忘
- 模块之间的隐式约束消失
- 实现呈现出“局部正确、整体错误”的特征
- 问题出现后，难以回溯根因

依赖“持续对话记忆”来完成复杂工程，本身就是一种高风险行为。

这并不是模型的问题，而是**工程假设的问题**。

---

## 4. Vibe + Coding 的核心假设

Vibe + Coding 建立在一个清晰而克制的假设之上：

> **AI 不适合长期持有复杂工程的整体语义。**

因此，我们不应要求 AI“记住整个项目”，
而应当主动改变工程组织方式：

- 将复杂问题拆分为相互独立的子任务
- 为每个子任务提供完整、封闭、可理解的说明
- 在可控上下文内完成执行
- 通过文档与测试保存决策结果

在这种结构下，AI 的不稳定性被限制在局部范围内，
而系统的整体语义由人类工程师把握。

---

## 5. 文档的角色被重新定义

在 Vibe + Coding 中，文档并不是事后补写的记录，
而是工程结构的一部分。

文档承担的是：

- 设计共识的承载体
- 决策冻结的边界
- 行为可审计的语义来源

它同时服务于三个对象：

- 向 Coding 阶段明确执行约束
- 向 Vibe 阶段提供稳定的记忆锚点
- 向未来的自己保存上下文

工程由此从“连续对话”转变为：

**离散、可版本化、可回溯的决策序列。**

---

## 6. 思考被前移，而不是被减少

需要明确的一点是：

Vibe + Coding 并不会减少思考量。

恰恰相反，它要求更高强度的前期思考。

许多原本可以在“写代码时顺便决定”的问题，
现在必须在 Vibe 阶段被显式想清楚、写下来并冻结。

这是一种明确的工程取舍：

- 用更多前期设计投入
- 换取更少低级实现劳动
- 换取更高的长期可维护性

如果你习惯于边写边想、先跑起来再说，
这一范式可能会让你感到不适。

但如果你认同设计优先、测试先行的工程方式，
你往往会获得更强的掌控感。

---

## 7. 关于适用范围的原则性说明

Vibe + Coding 并不是通用解法。

它更适合用于**设计主导型问题**，而非实现主导型问题。

当一个项目的核心难点在于：

- 系统如何拆分
- 抽象是否稳定
- 边界是否清晰
- 不变量能否长期成立

那么，设计质量远比实现速度重要。

在这类问题中，Vibe + Coding 的价值最为明显。

相反，当问题本质仍然是：

- 能不能做出来
- 性能能不能达标
- 方案是否可行

那么提前冻结设计往往是不合适的。

关于具体的误用场景与失败模式，将在后续章节中详细讨论。

---

## 8. 本章小结

Vibe + Coding 并不是捷径，也不是技巧集合。
它是一种工程立场的选择：

- 用结构换取稳定
- 用文档换取记忆
- 用设计换取规模
- 用前期思考换取长期收益

当工程师专注于“该做什么、为什么如此”，
而 AI 专注于“如何在约束下正确执行”，
协作才真正成立。

这正是本指南试图建立的核心设计理念。

# 第二章｜心智模型（Mental Model）

在进入任何流程、模板或具体实践之前，必须先建立一个正确的心智模型。
如果心智模型是错的，那么无论后续步骤多么完整、模板多么精细，流程最终都会退化回旧的 Vibe Coding：
单一对话、边聊边写、设计被实现牵着走。

**Vibe + Coding 的关键，并不在于“怎么用 AI”，
而在于你如何看待自己，以及如何看待 AI。**

---

## 1. 一个根本性的转变：你不再是“使用者”

在旧的 Vibe Coding 中，工程关系往往是隐含的：

- 你提出需求
- 你描述想法
- 你等待 AI 给出结果

而 AI 被默认为一个：

- 能理解需求
- 能设计方案
- 能完成实现
- 能顺便调试

的“全能黑盒”。

这种关系的本质是：

> **人类在请求，AI 在代替完成。**

在 Vibe + Coding 中，这种关系必须被彻底打破。

你不再是：

- 工具的使用者
- 提示词工程师
- 等结果的人

你扮演的角色是：

**Staff Engineer / Tech Lead。**

这意味着：

- 你对系统整体负责
- 你对架构质量负责
- 你对长期可维护性负责
- 你对所有关键设计拥有最终裁决权

AI 不再是“替你把事情做完的人”，
而是**被你组织、约束、分工的工程资源**。

---

## 2. 不是一个 AI，而是三个工程角色

Vibe + Coding 并不是“更聪明地使用 AI”，
而是将一个真实工程团队的分工，压缩映射为一个**个人可控的协作模型**。

在这个模型中，始终存在三个明确角色。

---

### 2.1 你：系统的唯一责任人

你是整个系统的所有者。

你的职责不是写最多的代码，而是做出最重要的判断：

- 系统到底要解决什么问题
- 哪些问题不解决
- 系统边界在哪里
- 哪些抽象值得长期存在
- 哪些设计结论需要被冻结

你负责的是：

- 设计取舍
- 架构判断
- 责任归属

而不是：

- 重复实现
- 框架样板
- 机械劳动

你产出的核心成果不是代码，而是**决策**。

---

### 2.2 Vibe Agent：设计协作者

Vibe Agent 只参与一件事：

**思考阶段。**

它的作用是帮助你：

- 澄清尚不清晰的想法
- 拆解复杂问题
- 暴露隐含假设
- 提出结构化的候选方案
- 将思考过程外显为文档

它更像是：

- 一个设计讨论对象
- 一个思考放大器
- 一个高智商的小黄鸭

Vibe Agent 的价值不在于“给出正确答案”，
而在于：

> **帮助你把脑中尚未成形的判断，变成可讨论、可冻结的结构。**

需要非常明确的一点是：

- Vibe Agent 没有决策权
- 所有设计结论都必须由你确认
- 它给出的永远只是候选，而不是事实

---

### 2.3 Coding Agent：受约束的执行者

Coding Agent 的角色非常单一。

它的职责只有一件事：

> **按照文档和测试，把事情正确地做出来。**

它可以：

- 根据文档实现功能
- 根据测试修复实现
- 汇报实现结果

它不应该：

- 参与架构讨论
- 重新设计接口
- 修改抽象边界
- 引入未说明的行为

在 Vibe + Coding 中，有一条非常重要的纪律：

> **Coding Agent 不允许做“看起来更好”的决定。**

只要某个行为没有被文档明确允许，
它就不应该发生。

一旦 Coding Agent 开始“自行优化”，
就说明流程已经出错。

---

## 3. 文档：冻结共识，而不是说明材料

在 Vibe + Coding 中，文档的角色被彻底重新定义。

文档不是：

- 教程
- 使用说明
- 对外展示材料

而是：

**设计共识的冻结形式。**

你可以将 Vibe 阶段理解为一场持续进行的技术会议：

- 你与 Vibe Agent 不断讨论
- 不断修正理解
- 不断收敛设计空间

而文档，就是这场会议的会议纪要。

它的作用是：

- 明确哪些事情已经被决定
- 阻止后续阶段反复推翻设计
- 为 Coding Agent 提供唯一权威输入
- 为未来的你保存决策上下文

当文档被冻结，就意味着：

- 设计阶段暂时结束
- 执行阶段正式开始

在这个范式中，不存在“先改代码再说”。

---

## 4. 测试：设计的可执行形式

在 Vibe + Coding 中，测试并不只是质量保障手段。

测试的真正角色是：

**设计文档的可执行契约。**

设计文档描述的是语义层面的约束：

- 什么应该发生
- 什么不应该发生

测试则将这些约束转化为：

- 可验证的行为
- 可自动检查的规则

因此在层级关系上：

- 文档定义语义
- 测试定义行为
- 代码只是实现

Coding Agent 的目标不是“写代码”，
而是：

> **让实现满足测试所代表的设计约束。**

当测试与实现发生冲突时，问题只可能出在：

- 设计没有写清楚
- 或实现做错了

而不是测试“太严格”。

---

## 5. 一条清晰的工程责任链

将所有角色放在一起，可以得到一条非常清晰的责任链：

你
↓
设计判断
↓
文档
↓
测试
↓
代码

这条链路的意义在于：

- 出现问题时，知道该向哪一层追溯
- 明确哪一层拥有最终解释权

代码永远处在最底层。
它不拥有语义主权。

---

## 6. 失败几乎总是从角色混淆开始

几乎所有 Vibe + Coding 的失败案例，都源于同一个原因：

**角色边界被破坏。**

常见表现包括：

- 在 Coding 阶段讨论设计
- 在 Vibe 阶段纠结实现细节
- 让 Coding Agent 自行修改 API
- 用补丁代码掩盖设计缺陷

一旦角色混淆：

- 实现会反向绑架设计
- 文档失去权威性
- 系统开始不可控演化

这与人类工程团队中的失败模式完全一致。

---

## 7. 正确的心理预期

在一个健康的 Vibe + Coding 流程中，你应当有如下感受：

- Vibe 阶段推进缓慢，但高度集中
- Coding 阶段推进迅速，且偏机械
- 思考强度前移
- 实现成本显著下降

这是正常状态。

如果你感觉：

- 写代码比设计更困难
- 实现阶段不断被迫“补设计”

那通常意味着：

> 设计阶段并没有真正完成。

---

## 8. 本章小结

在 Vibe + Coding 中：

- 你是系统的唯一责任人
- Vibe Agent 是设计协作者
- Coding Agent 是受约束的执行者
- 文档是冻结共识与工程记忆
- 测试是设计的行为契约

当这些角色各司其职、互不越界时，
AI 才能从不稳定的生成器，转变为：

**可靠、可审计、可复用的工程执行单元。**

理解这一心智模型，是进入后续方法论与实践章节的前提。

# 第三章｜方法论 - Vibe（Methodology Framework）

在确立设计理念与心智模型之后，才有资格讨论一个真正现实的问题：

**Vibe + Coding 究竟是如何运作的？**

本章不会涉及任何具体工具、平台或 prompt 写法。
这些都属于实现层问题，而不是方法论问题。

本章要给出的，是一套**稳定、可重复、可扩展的工程工作框架**，
用于回答一个更根本的问题：

> **如何把一个模糊、复杂、长期的工程问题，
> 转化为一系列 AI 可以被安全、可控执行的任务**
即如何**Vibe**。

---

## 1. 为什么必须有方法论，而不是“感觉对了就行”

在旧的 Vibe Coding 中，工程通常以一种连续对话的方式推进：

- 想法在聊天中逐步展开
- 决策隐含在上下文里
- 修改通过“再说一句话”完成

这种方式在小规模任务中看起来很自然，
但在工程尺度上会迅速暴露问题：

- 决策不可见
- 共识无法冻结
- 状态不可恢复
- 工程进展依赖模型记忆，而非结构

一旦对话变长，工程就开始建立在**不可靠的上下文连续性**之上。

Vibe + Coding 的一个核心目标，正是将工程从：

**连续对话流 → 离散决策结构**

只有当问题被拆分、被结构化、被显式记录，
AI 才能稳定执行，工程才具备可控性。

---

## 2. 四阶段模型总览
在Vibe阶段，Vibe + Coding 使用一个固定的四阶段模型，来组织所有设计活动：

**输入 → 对齐 → 细化 → 冻结**

这四个阶段共同构成完整的 **Vibe 阶段生命周期**。

需要强调的是：

- 它们不是一次性线性流程
- 可以回退
- 可以重复
- 可以嵌套

同一套模型，既适用于项目级架构设计，
也适用于一个最小功能单元的设计收敛。

---

## 3. 输入：给出讨论起点，而不是解决方案

输入 阶段的目标非常简单：

> **提供一个可以开始思考的起点。**

此时你不需要给出完整方案，
也不需要考虑实现细节。

输入 可以是：

- 一个模糊想法
- 一个目标描述
- 一个问题陈述

例如：

- “我想做一个象棋程序，支持双人对战和人机对战。”
- “我想设计一个用于评估 LLM 输出质量的框架。”

在这一阶段：

- 不追求完整性
- 不要求正确性
- 不进行技术选型

你只是明确一件事：

**这是我们接下来要认真讨论的问题。**

---

## 4. 对齐：对齐理解，而不是推进设计

对齐是整个 Vibe 阶段中**最关键、也最容易被跳过的一步**。

大量 Vibe Coding 的失败，并非源于设计能力不足，
而是从一开始就没有真正对齐：

**我们到底在讨论什么。**

对齐阶段的目标只有一个：

> **确保你与 Vibe Agent 对“要解决的问题本身”达成一致理解。**

这一阶段常见的工作包括：

- 让 Vibe Agent 复述当前问题定义
- 主动暴露不清晰或模糊之处
- 明确范围、目标与非目标

典型对齐问题包括：

- 这是本地程序还是服务端系统？
- 面向最终用户，还是内部工具？
- 是否需要长期扩展？
- 是否存在性能或稳定性要求？

对齐阶段的产出不是设计方案，
而是：

**一个被双方认可的问题定义。**

在没有完成对齐之前，不应进入任何设计。

---

## 5. 细化：将问题转化为结构

细化阶段的目标，是在已经对齐的问题定义之上，
逐步构建一个**可讨论、可修改、可落地的系统结构**。

这一阶段通常包括：

- 模块拆分
- 职责边界划分
- 技术路径讨论
- 数据与接口结构初步定义

在细化过程中，你可以：

- 要求 Vibe Agent 提出多种设计方案
- 比较不同方案的取舍
- 逐步缩小设计空间

需要强调的是：

- 此阶段仍然不写代码
- 所有内容仍然属于设计思考

你正在构建的不是实现，
而是：

> **一个人类可以理解、讨论并承担责任的系统模型。**

---

## 6. 冻结：冻结决策，形成工程共识

冻结是 Vibe + Coding 中**最重要、也最容易被忽视的一步**。

在这一阶段，你需要做一件明确的事情：

> **将当前阶段已经确认的设计结论固定下来。**

冻结的具体形式可以是：

- 一份设计文档
- 一个任务说明书
- 一个架构描述
- 一个模块边界定义

形式并不重要，重要的是语义：

- 哪些结论已经被接受
- 哪些内容暂不再讨论
- 后续执行必须严格以此为准

从冻结阶段开始：

- 设计进入只读状态
- 执行阶段获得稳定输入

任何新的想法，都必须：

- 显式打破冻结的共识
- 修改文档
- 再进入新一轮循环

不存在“先改代码再说”。

---

## 7. 分型递归：同一模型，不同尺度

这四个阶段并不仅用于项目顶层设计。

它们天然具备**分型递归特性**。

你可以对：

- 整个项目
- 单个模块
- 某个子系统
- 一个具体功能

重复执行：

**输入 → 对齐 → 细化 → 冻结**

直到最终收敛到一个尺度：

> **可以被 Coding Agent 独立完成的原子任务。**

此时，该任务应当具备：

- 明确目标
- 明确输入与输出
- 明确约束条件
- 明确完成标准

这也意味着：

**Vibe 阶段结束，Coding 阶段开始。**

---

## 8. 深度优先，而非广度扩散

在实际工程中，强烈建议采用：

**深度优先（DFS），而非广度优先（BFS）** 的推进方式。

也就是说：

- 先将一个模块完整设计到可执行级别
- 完成其实现与验证
- 再进入下一个模块

原因非常现实：

- AI 不擅长同时维护多个未冻结设计
- 半成品模块越多，语义污染越严重
- 未冻结设计之间极易相互干扰

DFS 能最大程度维持设计稳定性。

---

## 9. 本章小结

本章介绍的四阶段模型：

**输入 → 对齐 → 细化 → 冻结**

构成了 Vibe + Coding 的方法论核心。

它的目标不是让工程变快，
而是让工程变得：

- 可控
- 可回溯
- 可执行

当你能够熟练地在这四个阶段之间切换，
并知道什么时候该前进、什么时候该冻结，
你就已经具备了将复杂工程问题，
拆解为 AI 可安全执行任务的能力。

# 第四章｜实践流程 - Coding（Execution Workflow）

在完成设计哲学、心智模型与方法论框架之后，本章进入 **Vibe + Coding 的实际执行层**。

这一章只回答一个问题：

> **在 Vibe + Coding 范式下，一个任务是如何从“设计已冻结”，走到“代码被可靠合入”的？**
即如何Coding。

本章不再讨论“如何思考”，
而是明确一条 **从设计冻结到代码提交的标准工程闭环**。

---

## 1. 从设计冻结到执行：一次必要的工程跃迁

当 Vibe 阶段结束时，你通常已经拥有某种形式的设计产物：

- 架构或模块设计文档
- 功能说明
- API 约定
- 规则与不变量

但必须清醒地认识到一点：

**这些内容仍然是“人类可读”的设计语言。**

Coding Agent 并不具备在模糊语义中自行补全工程细节的能力，
也不应被允许这样做。

因此，在进入实现之前，必须完成一次关键转换：

> **将设计结论，转化为一个可被严格执行的工程任务。**

这一步不是形式转换，而是工程安全边界的建立。

---

## 2. 什么才算“可执行任务”

一个可以交付给 Coding Agent 的任务，必须满足以下条件：

- 任务边界清晰
- 行为范围明确
- 输入与输出可枚举
- 完成状态可判断

换句话说：

> **如果你无法明确判断“任务是否已经完成”，
> 那它就还不是一个工程任务。**

在 Vibe + Coding 中，任务说明不是“帮我实现一下这个功能”，
而是一张 **工程工单（engineering task）**。

Coding Agent 只执行工单，
不“理解背景”，不“补全意图”。

最简单的判断方式就是如果你自己作为这个工单的所有人，你能不能按照要求实现你自己的设计并且不背离原意。

---

## 3. 从设计到任务：必须显式完成的拆解

设计文档往往覆盖的是：

- 一个模块
- 一个子系统
- 或一个阶段性目标

而 Coding Agent 一次只能安全地处理：

> **一个原子级任务。**

因此，在实践中你必须显式完成以下拆解：

- 将设计文档拆分为若干原子任务
- 每个任务都可以独立实现、测试、审计
- 任务之间尽量减少隐式依赖

一个健康的任务应当具备：

- 明确目标
- 明确权威设计来源
- 明确约束与不变量
- 明确完成标准

这一步如果做得不充分，
后续所有问题都会集中爆发在实现阶段。

---

## 4. 测试优先：执行阶段的真正起点

在 Vibe + Coding 中，Coding 阶段**不是从写实现开始的**。

它必须从：

> **测试开始。**

原因很简单：

- 文档定义的是语义
- 测试定义的是行为
- 代码只是行为的实现

在一个健康的执行流程中，Coding Agent 的第一步应当是：

- 编写测试
- 运行测试
- 看到测试失败

这是一个积极信号，说明测试确实在约束行为。

如果测试一开始就通过，
那往往意味着测试并没有真正表达设计约束。

---

## 5. Coding Agent 的受限执行循环

在 Vibe + Coding 中，Coding Agent 的工作范围必须被严格限制在以下循环内：

1. 阅读任务说明
2. 编写或补充测试
3. 运行测试（失败）
4. 编写最小实现
5. 再次运行测试
6. 修正实现
7. 重复直到测试全部通过

Coding Agent **不允许**：

- 修改设计文档
- 扩展任务范围
- 引入未说明的行为
- 重构结构以“看起来更好”

它的唯一目标是：

> **让实现满足既定测试所代表的设计约束。**

---

## 6. 实现报告：执行阶段必须留下的痕迹

任务完成后，流程并未结束。

Coding Agent 必须输出一份 **实现报告**，至少回答以下问题：

- 实现了哪些功能
- 哪些实现对应哪些设计约束
- 是否存在假设或歧义
- 是否有需要人工确认的地方

实现报告不是总结文本，
而是：

> **执行过程的可审计记录。**

没有实现报告的代码，
不应被直接合入主干。

---

## 7. 回流审阅：设计与实现的对账机制

在 Coding Agent 完成任务后，你需要将以下内容带回 Vibe 阶段：

- 实现代码
- 测试
- 实现报告

审阅的核心问题是：

- 实现是否完全遵循文档？
- 文档是否存在表达歧义？
- 是否出现“设计未覆盖的行为”？

根据审阅结果，问题应被明确分类为：

- **设计问题** → 修改文档，重新 Freeze
- **实现问题** → 修正测试或代码

一个重要原则是：

> **永远不要用 patch 代码来掩盖设计问题。**

---

## 8. 提交与阶段性确认

当任务通过审阅后，应完成以下动作：

- 本地代码 review
- 单元测试 / 集成测试验证
- Git commit

推荐实践是：

> **一个冻结文档版本，对应一个 commit。**

这样可以确保：

- 任何设计决策都可被追溯
- 任意问题都能定位到设计上下文

代码历史由此具备工程意义，而不仅是修改记录。

---

## 9. 集成意识：不要把问题留到最后

在真实工程中，严重问题往往并不出现在模块内部，
而出现在模块之间。

因此，在多个任务完成后，必须显式进行：

- 集成测试
- 最小可运行路径验证
- 上下游协同检查

**不要等所有模块完成后再合龙。**

这是实践中最常见、也最昂贵的错误之一。

---

## 10. 重构的正确姿势

重构在长期项目中不可避免，
但在 Vibe + Coding 中，它同样必须遵循范式：

- 先修改文档
- 再调整测试
- 最后执行实现

**不允许 silent refactor。**

任何没有对应设计变更的结构修改，
都会破坏系统的可审计性。

---

## 11. 本章小结

本章给出了一条完整、可执行的工程闭环：

冻结文档（Vibe Agent）
→ 原子任务（Vibe Agent）
→ 测试设计（Vibe Agent）
→ 测试实现（Coding Agent）
→ 代码写作（Coding Agent）
→ 实现报告（Coding Agent）
→ 回流审阅 （Vibe Agent）
→ 提交确认 （人类）

通过这条流程：

- 执行被严格约束
- 设计拥有最终解释权
- AI 被限制在安全的工程角色内

# 第五章｜示意性样例：用 Vibe + Coding 串起一次完整流程（Illustrative Walkthrough）

本章**不是一个真实、完整、可直接复现的工程案例**。
它也不试图覆盖一个项目从零到一的全部细节。

本章的唯一目的是：

> **用一个“假想但足够具体”的示例，把 Vibe + Coding 的每一个关键步骤串起来，
> 让你清楚地看到：在每一步，你应该做什么，而不是怎么写代码。**

因此，你应当把本章理解为：

- 一张流程示意图
- 一次“演练式 walkthrough”
- 一套可迁移的操作骨架

而不是：

- 完整教程
- 最佳实现方案
- 现实项目蓝本

---

## 阅读约定（非常重要）

- 本章中的示例 **刻意保持简化**
- 所有 prompt 都是**示意性 prompt**
- 输出内容 **不追求完整性，只追求方向正确**
- 示例项目（象棋）只是一个载体，而非重点

不要试图“照抄本章直接写项目”。

---

## 0. 示例问题设定（仅用于说明流程）

我们假设有这样一个工程想法：

- 项目：象棋（Chess）
- 目标：支持两人本地对战
- 交互：命令行
- 语言：Python
- 非目标：
  - GUI
  - 网络对战
  - 性能优化
  - 人机智能算法

这个问题具备两个特征：

- 规则明确
- 状态复杂

非常适合用来**展示流程，而不是展示技巧**。

---

## Step 1 — 输入：只声明问题，不让 AI 设计

### 这一阶段你在做什么

你只是告诉 Vibe Agent：

> “我们接下来要认真讨论的是这件事。”

而不是：

> “你来帮我设计 / 实现这个系统。”

### 示意性 Vibe Prompt（Input）

- 我想做一个象棋程序，使用 Python。
- 第一阶段只考虑本地双人对战，命令行即可。
- 先不要设计，也不要写代码。
- 请你先记录我的描述。
- 在我说“输入结束”之后，只做两件事：
  1) 复述你理解的需求；
  2) 列出你认为还不清楚的地方。

输入结束。

### 💡 小提示

如果 AI 已经开始讨论模块、类或实现方式，
说明你在 Input 阶段**没有成功阻止它进入设计模式**。

---

## Step 2 — 对齐：确认我们在讨论“同一件事”

### 这一阶段你在做什么

你不是在推进方案，
而是在消除误解。

对齐的目标不是“想得更好”，
而是“想得一致”。

### 示意性对齐方式

- 让 AI 复述需求
- 修正偏差
- 回答关键不确定点
- 明确非目标

### 💡 小提示

“复述你理解的需求”这种复述式prompt适用于设计足够细致，要求足够明确的输入；
“列出你认为还不清楚的地方”这种反问时prompt适用于模糊性输入，这样反问可以快速缩减设计空间。

---

## Step 3 — 细化：把问题变成结构

### 这一阶段你在做什么

你开始允许 AI 参与**结构性思考**，
但讨论对象仍然是：

- 模块
- 职责
- 数据
- 流程

而不是实现。

### 示意性 Vibe Prompt（Refine）

- 基于当前已对齐的需求：
  - 给出一个最小可行的系统结构
  - 说明模块划分与职责
  - 描述核心数据模型
  - 描述最小执行流程
- 不写代码，只输出结构化设计。

### 💡 小提示

Refine 阶段最常见的错误是：

- 过早纠结实现细节
- 试图“一次性设计最终形态”

你此时要的只是：
**一个可以被写进文档的系统模型。**

---

## Step 4 — Freeze：把讨论变成文档

### 这一阶段你在做什么

你在做一件非常关键、但经常被跳过的事：

> **把“我们现在认为对的东西”固定下来。**

### 示意性 Freeze 行为

- 要求 AI 将当前设计整理为文档
- 明确这是阶段性结论
- 明确这是后续执行的权威来源

### 💡 小提示

一个简单判断标准是：

> 如果你现在愿意把这份文档交给一个
> “只执行、不思考”的人，那 Freeze 就是合格的。

---

## Step 5 — 从文档到任务：示意性的 DFS 拆分

### 这一阶段你在做什么

你不是在规划整个项目，
而是在回答：

> “接下来，哪一小块可以被独立完成？”

### 示意性拆分结果

例如：

- Task 1：棋盘与坐标系统
- Task 2：棋子抽象
- Task 3：走子表示
- …

每一个 Task 都应该是：

- 可独立实现
- 可测试
- 可审计

---

## Step 6 — 为单个任务写清楚“该怎么执行”

### 这一阶段你在做什么

你正在把一个任务，
从“工程师能理解”，
变成“执行者也不会猜错”。

### 示意性任务文档应包含

- 任务目标
- 权威设计来源
- 范围与边界
- 行为约束
- 完成标准

### 💡 小提示

自检问题只有一个：

> **如果我是执行者，这份说明是否已经不需要猜？**

---

## Step 7 — Coding：切换会话，只执行

### 这一阶段你在做什么

你在**刻意降低 AI 的自由度**。

- 新会话
- 无历史上下文
- 只提供任务文档

### 示意性 Coding Prompt 特征

- 明确这是执行任务
- 明确权威来源
- 明确禁止事项
- 要求测试优先
- 要求实现报告

### 💡 小技巧：上下文健康信号

一个实用的小技巧是：

- 在 Coding 会话中，要求 AI 在每次回复结尾输出一个固定格式（例如当天日期）
- 一旦连续回应中该格式消失，立刻停止并新开会话

这通常意味着上下文窗口已经开始影响模型稳定性。

---

## Step 8 — 回流审阅：不是“看代码”，而是“对文档”

### 这一阶段你在做什么

你不是在问：

> “代码写得好不好？”

而是在问：

> “代码是否忠实执行了文档？”

任何偏差，都必须被明确归因到：

- 设计问题
- 或执行问题

而不是用 patch 掩盖。

---

## 本章小结

本章通过一个**刻意简化的示意样例**，
展示了 Vibe + Coding 的完整操作骨架：

- 如何开始讨论
- 如何对齐
- 如何收敛
- 如何冻结
- 如何拆解
- 如何执行
- 如何回看

你不需要记住象棋，
也不需要记住这些 prompt。

你需要记住的只有一件事：

> **在每一步，你究竟是在思考，
> 还是在执行。**

一旦这两件事被混在一起，
流程就会退化。

# 第六章｜常见错误与工程取舍

Vibe + Coding 并不是一个“只要照着做就一定成功”的流程。
它是一套**高度依赖工程纪律的范式**。

一旦关键约束被破坏，流程往往不会立刻崩溃，
而是以一种非常隐蔽的方式逐渐退化，最终回到旧的 Vibe Coding。

本章的目标并不是列举“坏习惯”，
而是帮助你识别那些**正在说明你用错了范式、或不该使用该范式的信号**，
并在工程真正失控之前做出取舍与纠偏。

---

## 1. 最危险的反模式：角色混合

这是 Vibe + Coding 中**最常见、也是最致命的失败来源**。

### 表现形式

- 在 Coding 阶段讨论架构设计
- 让 Coding Agent“顺便优化一下结构”
- 设计尚未冻结就开始写代码
- 在 Vibe 阶段不断插入实现细节

### 后果

- 实现开始反向主导设计
- 文档逐渐失去权威性
- 决策被隐藏进代码细节
- 系统进入不可审计状态

### 工程含义

一旦角色边界被打破，
Vibe + Coding 就已经不再成立。

### 修正方式

- 立即停止执行
- 回到文档
- 明确当前处于 Vibe 还是 Coding 阶段
- 恢复角色隔离与上下文隔离

---

## 2. 用代码补丁掩盖设计问题

这是第二常见、但更隐蔽的退化路径。

### 表现形式

- “这个地方有点怪，先 patch 一下吧”
- “先让它跑起来，之后再补文档”
- “文档没写清，但代码这样也行”

### 问题本质

**设计缺陷被转化为实现复杂度。**

短期看似高效，
长期结果几乎必然是：

- 设计越来越空
- 代码越来越重
- 系统逐渐无人敢改

### 原则

任何非预期行为，都必须回到文档层解决。

**代码不能解释设计。**
只有文档拥有语义解释权。

---

## 3. 文档漂移：说的和做的已经不是一回事

### 表现形式

- 文档长期不再更新
- 实现明显超出文档范围
- 测试开始验证“真实行为”，而非设计行为

### 危险信号

- 新成员只能通过读代码理解系统
- 文档仅剩“历史痕迹价值”

这意味着：

> 工程已经退化为隐式知识系统。

### 修正方式

- 暂停新功能开发
- 对文档与实现进行系统性对账
- 明确哪些行为是事实，哪些应被废弃

---

## 4. 过度信任 AI 的“聪明”

这是一个心理层面的反模式。

### 表现形式

- “它应该能理解我的意思”
- “这个不用写文档也能明白吧”
- “模型这么强，不会出错的”

### 现实结果

- 隐式假设大量积累
- 小偏差被快速放大
- 错误难以复现、难以解释

Vibe + Coding 的核心前提是：

> **AI 只在约束之内可靠。**

任何脱离文档与测试的“聪明”，
都应被视为工程风险，而非能力优势。

---

## 5. 文档过度形式化

反模式并不只来自“太少”，
也可能来自“太多”。

### 表现形式

- 文档追求完美规格
- 试图一次性定义所有细节
- 写文档的成本接近写代码

### 后果

- 设计僵化
- 迭代速度急剧下降
- 工程失去探索空间

### 原则

文档的目标是：

> **足够清晰以执行，但不过度限制未来。**

文档冻结的是阶段性共识，而不是终极真理。

---

## 6. 把探索性问题强行塞进范式

这是一个非常常见的误用场景。

### 表现形式

- 尚不确定是否可行的算法
- 尚未验证的技术路线
- 强探索性、强不确定性问题

却试图：

- 编写完整设计文档
- 定义严格测试
- 冻结实现路径

### 结果

- 大量无效文档
- 设计频繁被推翻
- 心理负担极重

### 工程判断

当问题仍然是：

“能不能做到？”

而不是：

“怎么把它做好？”

此时使用 Vibe + Coding，本身就是一种错误。

---

## 7. 不适用场景被强行使用

以下场景一旦强行套用 Vibe + Coding，
几乎必然会出现前述所有退化问题：

- 一次性脚本
- 强 UI / UX 驱动的前端项目
- 高度依赖试错与调参的实现型任务
- 历史负担极重的屎山系统维护

在这些场景中：

- 文档成本 ≈ 实现成本
- 冻结设计缺乏现实基础

**范式的失败，并不意味着方法错误，
而是使用场景错误。**

---

## 8. 忽略集成层的风险

### 表现形式

- 单模块测试全部通过
- 系统整体运行失败
- 模块接口无法组合

### 原因

设计阶段过度关注模块内部，
而忽略模块之间的组合行为。

### 正确做法

- 为模块边界编写集成测试
- 尽早跑通最小可用路径
- 不等所有模块完成再合龙

---

## 9. 静默重构（Silent Refactor）

### 表现形式

- “顺手整理了一下代码结构”
- “只是重命名，不影响逻辑”
- 没有对应文档变更

### 风险

- 设计语义被悄然改变
- 历史决策丢失
- 调试与回溯成本激增

### 原则

> **没有文档记录的重构，不存在。**

---

## 10. 失控的早期信号

以下信号一旦出现，应立即警惕：

- 你开始频繁直接改代码
- 文档长期不再更新
- Coding Agent 经常“猜”你的意图
- 你需要反复解释同一件事
- 修 bug 时很难说明“为什么错”

这些都意味着：

> 工程正在偏离 Vibe + Coding 范式。

---

## 11. 本章小结

Vibe + Coding 的失败，
几乎从来不是模型能力不足，
而是**工程纪律的松动**。

当你发现流程开始变形时，不要试图“更努力地使用 AI”，
而应当：

- 回到角色划分
- 回到文档
- 回到测试
- 回到冻结点

Vibe + Coding 的价值不在于灵活，
而在于它在混乱中提供了一条**可以回退的路径**。

# 第七章｜总结（Conclusion）

本指南旨在提出一种 **Vibe + Coding** 的工程模式。
它并不试图让编程变得“轻松”，
而是利用 Vibe Coding 的能力，**提升工程实践的稳定性与可控性**。

---

## 1. Vibe + Coding 在做什么

Vibe + Coding 的核心思想，是将传统的 Vibe Coding **显式拆解为两个完全不同的 Agent 模块**：

- **Vibe Agent**：负责设计、思考、建模与文档化
- **Coding Agent**：负责在明确约束下执行实现

二者 **不共享任何上下文**，
唯一的通信方式是 **文档与测试**。

一个完整的循环是：

人类 + Vibe Agent 进行设计
→ 生成任务文档
→ Coding Agent 执行
→ 执行结果审计
→ 修改文档或代码
→ 进入下一轮

如此反复。

---

## 2. 为什么要如此严格地拆分

这一模式的关键价值，在于**彻底分离设计与实现**：

- 设计不再被实现细节反向污染
- 决策不再被“顺手写的代码”悄然改变
- 工程语义不再隐藏在实现细节中

它将重要的工程思考过程：

> 从“边写边想”
> 迁移为“想清楚再写”

而“写”的部分，则被完全、明确地委托给 Coding Agent。

---

## 3. 这不是捷径，而是一种工程立场

**Vibe + Coding 并不是捷径，也不是技巧集合。**

它是一种工程立场的选择：

- 用结构换取稳定
- 用文档换取记忆
- 用设计换取规模
- 用前期思考换取长期收益

你选择的不是“更快”，
而是“更可控”。

---

## 4. 必须改变的心智模型

要真正使用 Vibe + Coding，必须接受以下角色重构：

- **你是系统的唯一责任人**
  你的核心产出不是代码，而是**决策**。

- **Vibe Agent 是设计协作者**
  它的价值不在于“给出正确答案”，
  而在于：
  **帮助你把尚未成形的判断，转化为可讨论、可冻结的结构。**

- **Coding Agent 是受约束的执行者**
  它更像一名“将 ticket 变成代码的初级工程师”，
  不参与判断，只负责执行。

- **文档是冻结的共识与工程记忆**

- **测试是设计的行为契约**

---

## 5. Vibe 阶段：如何组织设计活动

在 Vibe 阶段，Vibe + Coding 使用一个固定的四阶段模型：

**输入 → 对齐 → 细化 → 冻结**

这四个阶段并不仅适用于项目顶层设计，
而是天然具备 **分型递归特性**。

你可以对：

- 整个项目
- 单个模块
- 某个子系统
- 一个具体功能

重复执行：

**输入 → 对齐 → 细化 → 冻结**

直到最终收敛到一个尺度：

> **可以被 Coding Agent 独立完成的原子任务。**

---

## 6. Coding 阶段：从冻结到提交的闭环

在 Coding 阶段，一条完整、受控的执行链路是：

冻结文档（Vibe Agent）
→ 原子任务（Vibe Agent）
→ 测试设计（Vibe Agent）
→ 测试实现（Coding Agent）
→ 代码写作（Coding Agent）
→ 实现报告（Coding Agent）
→ 回流审阅（Vibe Agent）
→ 提交确认（人类）

在这条链路中：

- 语义自上而下传递
- 责任自下而上回溯
- 每一层都有清晰的解释权边界

---

## 7. 关于失败的真正原因

Vibe + Coding 的失败，
**几乎从来不是模型能力不足**，
而是：

> **工程纪律的松动。**

当你发现流程开始变形时，不要试图：

“更努力地使用 AI”。

你真正应该做的是：

- 回到角色划分
- 回到文档
- 回到测试
- 回到冻结点

---

## 8. 最终结论

Vibe + Coding 的价值，不在于灵活，
而在于它在混乱中提供了一条：

> **可以回退的工程路径。**

当工程不再依赖隐式记忆与即兴发挥，
当决策被结构化、被冻结、可审计，
AI 才能真正成为可靠的工程执行单元。

这正是 Vibe + Coding 想要达到的目标。
