© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.2

---

# 第八章｜审计阶段（Audit Phase）

## 在执行结束之后，重新引入判断

在 Vibe + Coding 中，
**审计阶段是执行阶段之后，唯一被授权重新引入高责任判断的阶段。**

在进入审计阶段之前，有一个前提必须被明确：

> **执行已经结束，
> 执行体不再拥有任何行动权。**

审计阶段不再修改代码，
不再补充实现，
不再继续“把事情做完”。

它只做一件事：

**判断已经发生的执行行为，
是否落在既定授权边界之内。**

---

## 一、审计阶段的工程地位

审计阶段在工程流程中的位置是明确且不可替代的。

它不是执行阶段的延伸，
也不是下一个执行循环的开始，
而是一个**责任回收与边界校准的阶段**。

在这一阶段中：

- 判断权重新回到高责任角色
- 执行体的解释权被严格限制
- 结果的好坏不构成合法性的依据

审计阶段的核心问题不是：

“这样做对不对？”

而是：

> **“这样做，有没有被授权？”**

---

### 心智模型比喻｜战后评估，而不是现场指挥

### 心智模型比喻｜军纪审查，而不是战场指挥

在军事系统中，
战斗结束并不意味着一切自动合法。

真正决定行动是否被认可的，
不是前线的判断，
而是随后展开的**军纪与命令审查**。

在这一阶段：

- 不再下达新的作战命令
- 不再调整战术部署
- 不再讨论当时是否“更合理”

审查只基于三样东西：

- 既定的作战命令
- 事前明确的授权边界
- 战斗过程中留下的行动记录

评估的核心问题不是：

“如果当时换一种打法会不会更好？”

而是：

**“这些行动，是否在既定命令与授权之内发生？”**

审计阶段，正对应这一角色：
它不是继续指挥行动，
而是对行动是否遵守既定军纪与命令体系作出裁决。


---

## 二、审计阶段的唯一目标

审计阶段的目标可以被精确表述为：

> **基于既定的授权文档与执行记录，
> 对执行行为的合法性做出明确裁决。**

它不追求“工程最优解”，
也不负责“让系统变得更好”。

它只负责三件事：

- 确认哪些行为是合法的
- 识别哪些行为触及灰区
- 明确哪些行为构成越权

并为后续流程提供一个**清晰、不可歧义的裁决结果**。

---

## 三、审计输入工件：裁决的唯一事实基础

审计阶段并不“理解系统”，
也不“还原执行过程”。

它只做一件事：

**基于一组被明确允许的工程工件，
判断执行行为是否被授权。**

因此，在 Vibe + Coding 中，
**审计阶段的第一原则不是如何判断，
而是：哪些东西可以被用来判断。**

任何未被纳入审计输入工件范围的材料，
无论看起来多么合理、多么“有助于理解背景”，
在工程语义上都必须被视为不存在。

---

### 3.1 审计输入的冻结原则

审计阶段只接受执行阶段结束时已经存在的工件。

在审计过程中：

- 不允许补充新的解释性材料
- 不允许引入事后总结的“理解”
- 不允许根据结果反推执行意图

审计判断只基于当时已经留下的事实记录，
而非事后整理的叙述。

如果某个行为在执行阶段没有留下可被审计的痕迹，
那么它在审计语义中就是不可证明的。

---

### 3.2 核心审计输入工件清单

审计阶段必须、且只允许使用以下工件作为判断依据。

#### 3.2.1 冻结的设计文档

冻结的设计文档定义的是：

- 系统的语义边界
- 模块职责与不变量
- 已完成并冻结的高责任判断

在审计阶段：

- 设计文档是最高语义权威
- 用于判断某一类行为是否原则上被允许存在

审计不评估设计是否合理，
只评估设计是否被遵守。

---

#### 3.2.2 对应版本的任务说明书

任务说明书是执行阶段的直接授权书。

它定义的是：

- 本次任务被允许触碰的范围
- 明确冻结的工程事实
- 验收与完成的判据

在审计阶段，任务说明书用于判断：

- 某一具体行为是否被明确授权
- 某一取舍是否仍然落在授权空间之内

任何既未被授权、
也无法被归类为最小原则下必要取舍的行为，
都将被视为越权候选。

---

#### 3.2.3 实现代码与验证结果

实现代码与测试结果用于回答：

**执行体实际做了什么。**

它们不是权威来源，
也不具备裁决地位。

代码是否优雅、
测试是否全部通过，
本身不构成合法性的证明，
它们只是行为发生的证据。

---

#### 3.2.4 实现报告（Execution Report）

实现报告是执行阶段必须留下的解释性工件。

它用于：

- 标注实现行为与授权条目的对应关系
- 明确是否触及文档灰区
- 说明是否采用最小原则下的取舍

在审计阶段，
实现报告不是辩护词，
而是执行体对自身行为的结构化标注。

---

#### 3.2.5 执行阶段产生的记录与标注

包括但不限于：

- 灰区触发记录
- 执行中止标注
- 明确声明的越界行为及其原因

这些记录的价值不在于解释是否充分，
而在于是否承认并显式暴露了越界的发生。

未被记录的越界，
在审计语义中被视为隐性扩权。

---

### 3.3 明确排除的非审计输入

以下内容被明确禁止作为审计依据：

- 执行体的主观意图
- 口头或临时解释
- 结果导向的合理性辩护
- 事后补写的设计理解
- 未被冻结的草稿或中间文档

这些内容可能在工程上“有帮助”，
但在责任结构上不可接受。

---

### 3.4 输入工件不完整时的默认裁决立场

当审计输入工件存在缺失、模糊或无法对齐时，
审计阶段采取：

**不利于执行体的解释优先原则。**

这不是惩罚，
而是一种结构性约束，
用于鼓励在执行阶段留下充分痕迹，
并防止通过事后解释逃避裁决。

---

## 四、审计关注的裁决问题

审计阶段关注的不是任务是否完成，
而是以下问题：

- 执行行为是否落在授权边界内
- 是否存在灰区下的最小原则执行
- 是否存在未记录、未声明的隐性扩权

审计结论必须明确归类为：

- 合法执行
- 灰区但可接受
- 明确越权

不存在“暂时不处理”的合法状态。

---

## 五、裁决后的唯一合法处理路径

当审计发现问题时，只允许两种处理结果：

1. 收紧授权
   - 判定行为未被授权
   - 要求回退或重写实现

2. 显式放权
   - 确认行为可接受
   - 将原本隐含的自由度写入文档
   - 重新冻结授权边界

审计阶段不追责，
它只做定界。

---

### 心智模型比喻｜不是惩罚，而是修正边界

审计不是为了否定执行，
而是为了防止系统在无意识中扩权。

---

## 六、审计结果作为工程工件

审计阶段必须产出正式的审计结果工件，明确记录：

- 裁决结论
- 所依据的输入工件
- 是否触发文档修订
- 对后续流程的影响

审计结果将直接影响：

- 后续分解是否合法
- 是否需要回退执行
- 系统授权边界是否发生变化

---

## 本章小结

审计阶段不是为了让系统“更聪明”，
而是为了让系统**不失控**。

通过冻结审计输入、限制裁决依据、
强制越权显性化：

- 执行不再依赖信任
- 判断不再依赖记忆
- 系统演化不再依赖侥幸

**审计的力量，
来自于它拒绝理解一切未被记录的合理性。**
