© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.2

---

# 第七章｜执行阶段（Execution Phase）

## 在既定授权下，消耗冻结语义

在分解阶段结束后，工程系统已经具备一个关键前提：

**执行阶段所需的一切高责任判断，已经完成并被冻结。**

执行阶段不再关心：
- 设计是否合理
- 决策是否最优
- 目标是否应该调整

它只关心一件事：

**如何在不突破授权边界的前提下，
将既定语义转化为可验证的工程现实。**

执行阶段不是设计的延续，
也不是决策的补充。

它是一段**受限、可回溯、可被完全审计的语义消耗过程**。

请注意，在Vibe + Coding范式中，这里Coding Agent和Vibe Agent是两个不同的Agent，二者交流的唯一通路是文档：设计文档和任务说明。
这两者不强制要求是具体的隔离形式，可以是ChatGPT + Cursor，可以是Copilot里面的不同对话，但是一定不能共享上下文。
这种方式在物理上避免了设计阶段的噪声穿透无知之幕进入执行阶段。


---

## 一、执行阶段的工程地位

在 Vibe + Coding 中，执行阶段被严格定义为：

**在任务说明书所界定的授权空间内，
完成一次最小、原子、可验证的工程实现。**

在这一阶段中：

- 不再允许引入新的设计判断
- 不再允许重新解释冻结语义
- 不再允许以“实现更合理”为由修改既有边界

执行阶段的合法性，完全依赖于分解阶段的产物。
一旦执行体开始工作，即默认接受以下事实：

- 目标已经确定
- 权威已经指定
- 边界已经冻结
- 完成判据已经定义

执行阶段无权质疑这些前提。

---

### 心智模型比喻｜命令已下达，行动已授权

在军事系统中，
一旦作战命令下达并生效：

- 前线单位不再讨论战略是否正确
- 不再重新评估政治目标
- 不再自行调整作战目的

其唯一职责是：

**在命令所允许的范围内，
以最可靠的方式完成行动。**

执行阶段正处于这一位置。

---

## 二、执行阶段的唯一输入

执行阶段只接受一种合法输入：

**已确认、已冻结、可审计的任务说明书。**

执行体不得：

- 追溯设计阶段的讨论过程
- 依赖口头解释或隐含背景
- 根据历史实现自行补全语义

在执行阶段：

- 设计文档只作为被引用的权威来源
- 任务说明书是唯一直接约束执行行为的工件

任何不在任务说明书中明确授权的行为，
在工程语义上默认不被允许。

---

## 三、执行体的受限行动循环

在 Vibe + Coding 中，执行体（包括 Coding Agent）的工作被限制在一个明确、封闭的执行循环内：

1. 阅读并确认任务说明书
2. 根据任务说明书中定义的验收语义，准备验证工件（通常为测试）
3. 运行验证工件，确认其初始失败状态
4. 编写最小实现以满足约束
5. 重新运行验证
6. 修正实现，直至全部约束满足

在这一循环中，执行体：

- 可以选择具体实现路径
- 可以在允许的范围内进行技术取舍
- 可以调整代码组织以满足既定规范

但不允许：

- 修改设计文档
- 扩展任务范围
- 引入未声明的行为
- 进行结构性重构以“提升整体质量”

执行阶段的成功标准只有一个：

**实现行为完全满足任务说明书所定义的可验证约束。**

---

## 四、最小原则：面对文档灰区的唯一合法策略

即使分解阶段已经尽力消除歧义，
在真实工程中，执行体仍可能遇到任务说明书未明确覆盖的情况。

在执行阶段，这类情况被统称为：

**文档灰区。**

面对文档灰区，执行阶段不允许引入新的设计判断。
唯一合法的处理原则是：

**最小原则（Minimal Principle）。**

最小原则意味着：

- 不扩展既有语义
- 不引入新的长期承诺
- 不增加不可逆的结构复杂度
- 选择影响面最小、可替换、可回退的实现方式

最小原则不是聪明实现，
而是一种刻意克制的工程姿态。

---

### 心智模型比喻｜在边界处机动，而不是改写命令

前线部队在执行过程中，
**可以在不得已的情况下进入原命令未明确授权的区域**，
例如因天气、地形或环境变化，
原定阵地已无法部署或继续推进。

在这种情况下，
前线部队可以后退、绕行，或临时占据替代位置，
以维持行动的连续性并完成既定任务。

但这种行为必须同时满足以下前提：

- 该越界行为必须以完成既定任务为唯一目的
- 越界范围应当保持在影响面最小的程度
- 所有越界行为及其触发原因必须被完整记录在案，
  以供事后检查与责任裁决

最小原则所对应的，
正是这种**在行动不中断的前提下，
允许有限越界，但拒绝隐性扩权的受限机动**。

---

## 五、越界是一种现实，而不是例外

Vibe + Coding 并不假设执行阶段永远正确。

相反，它明确承认：

**执行体在文档灰区发生越界，是一种可预期的工程现实。**

因此，体系的安全性并不依赖于：

- 执行体足够谨慎
- Agent 足够聪明
- Prompt 足够完美

而依赖于一个更根本的事实：

**越界是否能够被识别，
以及是否存在明确的回流与裁决机制。**

执行阶段本身不负责裁决越界是否合法，
它只负责留下足够清晰的痕迹，
以供后续审计阶段判断。

---

## 六、实现报告：执行阶段必须留下的工件

每一次执行任务完成后，
执行体必须输出一份实现报告。

实现报告不是总结性文字，
而是一份可被审计的执行记录，至少应当说明：

- 本次实现覆盖了哪些任务目标
- 实现如何对应任务说明书中的约束
- 是否遇到文档灰区
- 是否做出了最小原则下的取舍

实现报告的存在，使得执行阶段：

- 不再是黑箱
- 不依赖执行者记忆
- 不因人员或 Agent 更替而丢失上下文

---

## 执行中止条件：一种实现层防御机制

*本节为实现层建议，不构成方法论成立的必要条件。*

在部分高风险或高度不确定的工程环境中，
可以为执行体引入一组执行中止条件，用于提前暴露问题。

典型的中止触发情形包括：

- 任务说明书中的约束在工程上相互冲突
- 多种实现路径均涉及明显的设计性取舍
- 验证工件无法表达关键冻结语义

当中止条件被触发时，执行体应当：

- 停止进一步实现
- 明确记录触发原因
- 将问题上抛，交由后续阶段处理

需要强调的是：

**执行中止并不是为了保护执行体，
而是为了避免在执行阶段隐式承担设计责任。**

---

## 七、执行阶段的结束条件

执行阶段的结束，并不以代码写完为标志。

它必须同时满足：

- 所有验证工件通过
- 实现报告已生成
- 所有执行行为可被回溯到任务说明书中的授权条目

一旦这些条件成立，
执行阶段即告结束，
系统将进入下一个阶段。

---

## 本章小结

执行阶段不是一个发挥创造力的空间，
而是一个受限行动、受控消耗、等待审计的阶段。

在这一阶段中：

- 决策已经完成
- 授权已经明确
- 行动被严格约束
- 越界被允许发生，但不得被掩盖

通过这种设计：

- 执行可以被安全地外包
- 设计主权始终掌握在人类工程师手中
- 工程系统能够在长期演化中保持结构稳定

**执行的价值，不在于聪明，
而在于可控。**
