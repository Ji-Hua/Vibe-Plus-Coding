© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 引言｜Introduction

Vibe Coding 是一个非常好的工具。
作为一名长期从事系统设计与维护的工程师，我非常乐意使用任何能够降低实现劳动量的技术，而 AI 正是其中最具潜力的一种。

但在接近一年的实际使用过程中，我逐渐意识到一个问题：
**AI 并不能独立承担中大型系统的实现任务。**
甚至在稍微复杂一些的工程中，它也很容易出现结构失控、语义漂移和不可维护的问题。

这些问题往往并不体现在“代码能不能跑”，而体现在工程质量本身，例如：

- 编写与设计目标无关的代码
- 将本应通过参数或配置传递的内容硬编码进实现
- 随意加入无意义的日志、调试输出
- 函数接口定义混乱、职责不清
- 继承结构随意扩展，缺乏抽象边界
- 任意修改项目目录结构
- 无约束地安装依赖，引入隐性复杂度

我尝试过使用更复杂的 prompt、更严格的说明，甚至将 agent 行为一步步细化，但效果始终有限。
AI 在这种模式下，最多只能胜任简单、局部、低风险的功能实现；一旦任务复杂度上升，整个项目就会迅速失控。

真正的转折点，发生在一个看似普通的个人项目中。

当时我希望将一个桌游实现为 Web App。与以往不同的是，这一次我先写了规则说明书，然后基于规则设计了测试用例，再开始动手实现。
也正是在这一刻，我突然意识到：
**问题并不在于 AI 不够强，而在于我一直没有用对方式。**

作为一个写了十多年代码的工程师，我自己都无法保证每一行代码天然正确。
我同样需要说明文档来明确语义，需要测试来约束行为，需要结构来防止系统腐化。
那么，我凭什么要求 AI 在没有这些约束的情况下，独立完成复杂工程？

AI 的优势并不在于设计系统，而在于精确执行已经明确的决策。
而设计、取舍、权衡与责任归属，恰恰是人类工程师的核心价值所在。
换句话说，项目的所有权只能属于人类，决策也不应被外包给模型。

不同工程师写出的代码本就千差万别，AI 并无例外。

在意识到这一点之后，我开始有意识地调整工作方式：
先与 AI 共同完成设计文档，再冻结决策；
基于文档编写测试；
最后再让 AI 执行受约束的实现、运行、修复与重构。

我将这一模式应用在两个不同规模的项目中，结果都基本达到了我的工程预期。
至此，我确认：这并不是一次偶然的成功，而是一种可复用的工程范式。

我将这种工作方式命名为：**Vibe + Coding**。其中设计部分即Vibe，实现部分即Coding，二者通过文档进行交互。

本指南，正是对这一范式的系统性整理与总结。
