© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第三章｜方法论 - Vibe（Methodology Framework）

在确立设计理念与心智模型之后，才有资格讨论一个真正现实的问题：

**Vibe + Coding 究竟是如何运作的？**

本章不会涉及任何具体工具、平台或 prompt 写法。
这些都属于实现层问题，而不是方法论问题。

本章要给出的，是一套**稳定、可重复、可扩展的工程工作框架**，
用于回答一个更根本的问题：

> **如何把一个模糊、复杂、长期的工程问题，
> 转化为一系列 AI 可以被安全、可控执行的任务**
即如何**Vibe**。

---

## 1. 为什么必须有方法论，而不是“感觉对了就行”

在旧的 Vibe Coding 中，工程通常以一种连续对话的方式推进：

- 想法在聊天中逐步展开
- 决策隐含在上下文里
- 修改通过“再说一句话”完成

这种方式在小规模任务中看起来很自然，
但在工程尺度上会迅速暴露问题：

- 决策不可见
- 共识无法冻结
- 状态不可恢复
- 工程进展依赖模型记忆，而非结构

一旦对话变长，工程就开始建立在**不可靠的上下文连续性**之上。

Vibe + Coding 的一个核心目标，正是将工程从：

**连续对话流 → 离散决策结构**

只有当问题被拆分、被结构化、被显式记录，
AI 才能稳定执行，工程才具备可控性。

---

## 2. 四阶段模型总览
在Vibe阶段，Vibe + Coding 使用一个固定的四阶段模型，来组织所有设计活动：

**输入 → 对齐 → 细化 → 冻结**

这四个阶段共同构成完整的 **Vibe 阶段生命周期**。

需要强调的是：

- 它们不是一次性线性流程
- 可以回退
- 可以重复
- 可以嵌套

同一套模型，既适用于项目级架构设计，
也适用于一个最小功能单元的设计收敛。

---

## 3. 输入：给出讨论起点，而不是解决方案

输入 阶段的目标非常简单：

> **提供一个可以开始思考的起点。**

此时你不需要给出完整方案，
也不需要考虑实现细节。

输入 可以是：

- 一个模糊想法
- 一个目标描述
- 一个问题陈述

例如：

- “我想做一个象棋程序，支持双人对战和人机对战。”
- “我想设计一个用于评估 LLM 输出质量的框架。”

在这一阶段：

- 不追求完整性
- 不要求正确性
- 不进行技术选型

你只是明确一件事：

**这是我们接下来要认真讨论的问题。**

---

## 4. 对齐：对齐理解，而不是推进设计

对齐是整个 Vibe 阶段中**最关键、也最容易被跳过的一步**。

大量 Vibe Coding 的失败，并非源于设计能力不足，
而是从一开始就没有真正对齐：

**我们到底在讨论什么。**

对齐阶段的目标只有一个：

> **确保你与 Vibe Agent 对“要解决的问题本身”达成一致理解。**

这一阶段常见的工作包括：

- 让 Vibe Agent 复述当前问题定义
- 主动暴露不清晰或模糊之处
- 明确范围、目标与非目标

典型对齐问题包括：

- 这是本地程序还是服务端系统？
- 面向最终用户，还是内部工具？
- 是否需要长期扩展？
- 是否存在性能或稳定性要求？

对齐阶段的产出不是设计方案，
而是：

**一个被双方认可的问题定义。**

在没有完成对齐之前，不应进入任何设计。

---

## 5. 细化：将问题转化为结构

细化阶段的目标，是在已经对齐的问题定义之上，
逐步构建一个**可讨论、可修改、可落地的系统结构**。

这一阶段通常包括：

- 模块拆分
- 职责边界划分
- 技术路径讨论
- 数据与接口结构初步定义

在细化过程中，你可以：

- 要求 Vibe Agent 提出多种设计方案
- 比较不同方案的取舍
- 逐步缩小设计空间

需要强调的是：

- 此阶段仍然不写代码
- 所有内容仍然属于设计思考

你正在构建的不是实现，
而是：

> **一个人类可以理解、讨论并承担责任的系统模型。**

---

## 6. 冻结：冻结决策，形成工程共识

冻结是 Vibe + Coding 中**最重要、也最容易被忽视的一步**。

在这一阶段，你需要做一件明确的事情：

> **将当前阶段已经确认的设计结论固定下来。**

冻结的具体形式可以是：

- 一份设计文档
- 一个任务说明书
- 一个架构描述
- 一个模块边界定义

形式并不重要，重要的是语义：

- 哪些结论已经被接受
- 哪些内容暂不再讨论
- 后续执行必须严格以此为准

从冻结阶段开始：

- 设计进入只读状态
- 执行阶段获得稳定输入

任何新的想法，都必须：

- 显式打破冻结的共识
- 修改文档
- 再进入新一轮循环

不存在“先改代码再说”。

---

## 7. 分型递归：同一模型，不同尺度

这四个阶段并不仅用于项目顶层设计。

它们天然具备**分型递归特性**。

你可以对：

- 整个项目
- 单个模块
- 某个子系统
- 一个具体功能

重复执行：

**输入 → 对齐 → 细化 → 冻结**

直到最终收敛到一个尺度：

> **可以被 Coding Agent 独立完成的原子任务。**

此时，该任务应当具备：

- 明确目标
- 明确输入与输出
- 明确约束条件
- 明确完成标准

这也意味着：

**Vibe 阶段结束，Coding 阶段开始。**

---

## 8. 深度优先，而非广度扩散

在实际工程中，强烈建议采用：

**深度优先（DFS），而非广度优先（BFS）** 的推进方式。

也就是说：

- 先将一个模块完整设计到可执行级别
- 完成其实现与验证
- 再进入下一个模块

原因非常现实：

- AI 不擅长同时维护多个未冻结设计
- 半成品模块越多，语义污染越严重
- 未冻结设计之间极易相互干扰

DFS 能最大程度维持设计稳定性。

---

## 9. 本章小结

本章介绍的四阶段模型：

**输入 → 对齐 → 细化 → 冻结**

构成了 Vibe + Coding 的方法论核心。

它的目标不是让工程变快，
而是让工程变得：

- 可控
- 可回溯
- 可执行

当你能够熟练地在这四个阶段之间切换，
并知道什么时候该前进、什么时候该冻结，
你就已经具备了将复杂工程问题，
拆解为 AI 可安全执行任务的能力。
