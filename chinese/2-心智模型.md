© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第二章｜心智模型（Mental Model）

在进入任何流程、模板或具体实践之前，必须先建立一个正确的心智模型。
如果心智模型是错的，那么无论后续步骤多么完整、模板多么精细，流程最终都会退化回旧的 Vibe Coding：
单一对话、边聊边写、设计被实现牵着走。

**Vibe + Coding 的关键，并不在于“怎么用 AI”，
而在于你如何看待自己，以及如何看待 AI。**

---

## 1. 一个根本性的转变：你不再是“使用者”

在旧的 Vibe Coding 中，工程关系往往是隐含的：

- 你提出需求
- 你描述想法
- 你等待 AI 给出结果

而 AI 被默认为一个：

- 能理解需求
- 能设计方案
- 能完成实现
- 能顺便调试

的“全能黑盒”。

这种关系的本质是：

> **人类在请求，AI 在代替完成。**

在 Vibe + Coding 中，这种关系必须被彻底打破。

你不再是：

- 工具的使用者
- 提示词工程师
- 等结果的人

你扮演的角色是：

**Staff Engineer / Tech Lead。**

这意味着：

- 你对系统整体负责
- 你对架构质量负责
- 你对长期可维护性负责
- 你对所有关键设计拥有最终裁决权

AI 不再是“替你把事情做完的人”，
而是**被你组织、约束、分工的工程资源**。

---

## 2. 不是一个 AI，而是三个工程角色

Vibe + Coding 并不是“更聪明地使用 AI”，
而是将一个真实工程团队的分工，压缩映射为一个**个人可控的协作模型**。

在这个模型中，始终存在三个明确角色。

---

### 2.1 你：系统的唯一责任人

你是整个系统的所有者。

你的职责不是写最多的代码，而是做出最重要的判断：

- 系统到底要解决什么问题
- 哪些问题不解决
- 系统边界在哪里
- 哪些抽象值得长期存在
- 哪些设计结论需要被冻结

你负责的是：

- 设计取舍
- 架构判断
- 责任归属

而不是：

- 重复实现
- 框架样板
- 机械劳动

你产出的核心成果不是代码，而是**决策**。

---

### 2.2 Vibe Agent：设计协作者

Vibe Agent 只参与一件事：

**思考阶段。**

它的作用是帮助你：

- 澄清尚不清晰的想法
- 拆解复杂问题
- 暴露隐含假设
- 提出结构化的候选方案
- 将思考过程外显为文档

它更像是：

- 一个设计讨论对象
- 一个思考放大器
- 一个高智商的小黄鸭

Vibe Agent 的价值不在于“给出正确答案”，
而在于：

> **帮助你把脑中尚未成形的判断，变成可讨论、可冻结的结构。**

需要非常明确的一点是：

- Vibe Agent 没有决策权
- 所有设计结论都必须由你确认
- 它给出的永远只是候选，而不是事实

---

### 2.3 Coding Agent：受约束的执行者

Coding Agent 的角色非常单一。

它的职责只有一件事：

> **按照文档和测试，把事情正确地做出来。**

它可以：

- 根据文档实现功能
- 根据测试修复实现
- 汇报实现结果

它不应该：

- 参与架构讨论
- 重新设计接口
- 修改抽象边界
- 引入未说明的行为

在 Vibe + Coding 中，有一条非常重要的纪律：

> **Coding Agent 不允许做“看起来更好”的决定。**

只要某个行为没有被文档明确允许，
它就不应该发生。

一旦 Coding Agent 开始“自行优化”，
就说明流程已经出错。

---

## 3. 文档：冻结共识，而不是说明材料

在 Vibe + Coding 中，文档的角色被彻底重新定义。

文档不是：

- 教程
- 使用说明
- 对外展示材料

而是：

**设计共识的冻结形式。**

你可以将 Vibe 阶段理解为一场持续进行的技术会议：

- 你与 Vibe Agent 不断讨论
- 不断修正理解
- 不断收敛设计空间

而文档，就是这场会议的会议纪要。

它的作用是：

- 明确哪些事情已经被决定
- 阻止后续阶段反复推翻设计
- 为 Coding Agent 提供唯一权威输入
- 为未来的你保存决策上下文

当文档被冻结，就意味着：

- 设计阶段暂时结束
- 执行阶段正式开始

在这个范式中，不存在“先改代码再说”。

---

## 4. 测试：设计的可执行形式

在 Vibe + Coding 中，测试并不只是质量保障手段。

测试的真正角色是：

**设计文档的可执行契约。**

设计文档描述的是语义层面的约束：

- 什么应该发生
- 什么不应该发生

测试则将这些约束转化为：

- 可验证的行为
- 可自动检查的规则

因此在层级关系上：

- 文档定义语义
- 测试定义行为
- 代码只是实现

Coding Agent 的目标不是“写代码”，
而是：

> **让实现满足测试所代表的设计约束。**

当测试与实现发生冲突时，问题只可能出在：

- 设计没有写清楚
- 或实现做错了

而不是测试“太严格”。

---

## 5. 一条清晰的工程责任链

将所有角色放在一起，可以得到一条非常清晰的责任链：

你
↓
设计判断
↓
文档
↓
测试
↓
代码

这条链路的意义在于：

- 出现问题时，知道该向哪一层追溯
- 明确哪一层拥有最终解释权

代码永远处在最底层。
它不拥有语义主权。

---

## 6. 失败几乎总是从角色混淆开始

几乎所有 Vibe + Coding 的失败案例，都源于同一个原因：

**角色边界被破坏。**

常见表现包括：

- 在 Coding 阶段讨论设计
- 在 Vibe 阶段纠结实现细节
- 让 Coding Agent 自行修改 API
- 用补丁代码掩盖设计缺陷

一旦角色混淆：

- 实现会反向绑架设计
- 文档失去权威性
- 系统开始不可控演化

这与人类工程团队中的失败模式完全一致。

---

## 7. 正确的心理预期

在一个健康的 Vibe + Coding 流程中，你应当有如下感受：

- Vibe 阶段推进缓慢，但高度集中
- Coding 阶段推进迅速，且偏机械
- 思考强度前移
- 实现成本显著下降

这是正常状态。

如果你感觉：

- 写代码比设计更困难
- 实现阶段不断被迫“补设计”

那通常意味着：

> 设计阶段并没有真正完成。

---

## 8. 本章小结

在 Vibe + Coding 中：

- 你是系统的唯一责任人
- Vibe Agent 是设计协作者
- Coding Agent 是受约束的执行者
- 文档是冻结共识与工程记忆
- 测试是设计的行为契约

当这些角色各司其职、互不越界时，
AI 才能从不稳定的生成器，转变为：

**可靠、可审计、可复用的工程执行单元。**

理解这一心智模型，是进入后续方法论与实践章节的前提。
