© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第四章｜实践流程 - Coding（Execution Workflow）

在完成设计哲学、心智模型与方法论框架之后，本章进入 **Vibe + Coding 的实际执行层**。

这一章只回答一个问题：

> **在 Vibe + Coding 范式下，一个任务是如何从“设计已冻结”，走到“代码被可靠合入”的？**
即如何Coding。

本章不再讨论“如何思考”，
而是明确一条 **从设计冻结到代码提交的标准工程闭环**。

---

## 1. 从设计冻结到执行：一次必要的工程跃迁

当 Vibe 阶段结束时，你通常已经拥有某种形式的设计产物：

- 架构或模块设计文档
- 功能说明
- API 约定
- 规则与不变量

但必须清醒地认识到一点：

**这些内容仍然是“人类可读”的设计语言。**

Coding Agent 并不具备在模糊语义中自行补全工程细节的能力，
也不应被允许这样做。

因此，在进入实现之前，必须完成一次关键转换：

> **将设计结论，转化为一个可被严格执行的工程任务。**

这一步不是形式转换，而是工程安全边界的建立。

---

## 2. 什么才算“可执行任务”

一个可以交付给 Coding Agent 的任务，必须满足以下条件：

- 任务边界清晰
- 行为范围明确
- 输入与输出可枚举
- 完成状态可判断

换句话说：

> **如果你无法明确判断“任务是否已经完成”，
> 那它就还不是一个工程任务。**

在 Vibe + Coding 中，任务说明不是“帮我实现一下这个功能”，
而是一张 **工程工单（engineering task）**。

Coding Agent 只执行工单，
不“理解背景”，不“补全意图”。

最简单的判断方式就是如果你自己作为这个工单的所有人，你能不能按照要求实现你自己的设计并且不背离原意。

---

## 3. 从设计到任务：必须显式完成的拆解

设计文档往往覆盖的是：

- 一个模块
- 一个子系统
- 或一个阶段性目标

而 Coding Agent 一次只能安全地处理：

> **一个原子级任务。**

因此，在实践中你必须显式完成以下拆解：

- 将设计文档拆分为若干原子任务
- 每个任务都可以独立实现、测试、审计
- 任务之间尽量减少隐式依赖

一个健康的任务应当具备：

- 明确目标
- 明确权威设计来源
- 明确约束与不变量
- 明确完成标准

这一步如果做得不充分，
后续所有问题都会集中爆发在实现阶段。

---

## 4. 测试优先：执行阶段的真正起点

在 Vibe + Coding 中，Coding 阶段**不是从写实现开始的**。

它必须从：

> **测试开始。**

原因很简单：

- 文档定义的是语义
- 测试定义的是行为
- 代码只是行为的实现

在一个健康的执行流程中，Coding Agent 的第一步应当是：

- 编写测试
- 运行测试
- 看到测试失败

这是一个积极信号，说明测试确实在约束行为。

如果测试一开始就通过，
那往往意味着测试并没有真正表达设计约束。

---

## 5. Coding Agent 的受限执行循环

在 Vibe + Coding 中，Coding Agent 的工作范围必须被严格限制在以下循环内：

1. 阅读任务说明
2. 编写或补充测试
3. 运行测试（失败）
4. 编写最小实现
5. 再次运行测试
6. 修正实现
7. 重复直到测试全部通过

Coding Agent **不允许**：

- 修改设计文档
- 扩展任务范围
- 引入未说明的行为
- 重构结构以“看起来更好”

它的唯一目标是：

> **让实现满足既定测试所代表的设计约束。**

---

## 6. 实现报告：执行阶段必须留下的痕迹

任务完成后，流程并未结束。

Coding Agent 必须输出一份 **实现报告**，至少回答以下问题：

- 实现了哪些功能
- 哪些实现对应哪些设计约束
- 是否存在假设或歧义
- 是否有需要人工确认的地方

实现报告不是总结文本，
而是：

> **执行过程的可审计记录。**

没有实现报告的代码，
不应被直接合入主干。

---

## 7. 回流审阅：设计与实现的对账机制

在 Coding Agent 完成任务后，你需要将以下内容带回 Vibe 阶段：

- 实现代码
- 测试
- 实现报告

审阅的核心问题是：

- 实现是否完全遵循文档？
- 文档是否存在表达歧义？
- 是否出现“设计未覆盖的行为”？

根据审阅结果，问题应被明确分类为：

- **设计问题** → 修改文档，重新 Freeze
- **实现问题** → 修正测试或代码

一个重要原则是：

> **永远不要用 patch 代码来掩盖设计问题。**

---

## 8. 提交与阶段性确认

当任务通过审阅后，应完成以下动作：

- 本地代码 review
- 单元测试 / 集成测试验证
- Git commit

推荐实践是：

> **一个冻结文档版本，对应一个 commit。**

这样可以确保：

- 任何设计决策都可被追溯
- 任意问题都能定位到设计上下文

代码历史由此具备工程意义，而不仅是修改记录。

---

## 9. 集成意识：不要把问题留到最后

在真实工程中，严重问题往往并不出现在模块内部，
而出现在模块之间。

因此，在多个任务完成后，必须显式进行：

- 集成测试
- 最小可运行路径验证
- 上下游协同检查

**不要等所有模块完成后再合龙。**

这是实践中最常见、也最昂贵的错误之一。

---

## 10. 重构的正确姿势

重构在长期项目中不可避免，
但在 Vibe + Coding 中，它同样必须遵循范式：

- 先修改文档
- 再调整测试
- 最后执行实现

**不允许 silent refactor。**

任何没有对应设计变更的结构修改，
都会破坏系统的可审计性。

---

## 11. 本章小结

本章给出了一条完整、可执行的工程闭环：

冻结文档（Vibe Agent）
→ 原子任务（Vibe Agent）
→ 测试设计（Vibe Agent）
→ 测试实现（Coding Agent）
→ 代码写作（Coding Agent）
→ 实现报告（Coding Agent）
→ 回流审阅 （Vibe Agent）
→ 提交确认 （人类）

通过这条流程：

- 执行被严格约束
- 设计拥有最终解释权
- AI 被限制在安全的工程角色内
