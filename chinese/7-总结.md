© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第七章｜总结（Conclusion）

本指南旨在提出一种 **Vibe + Coding** 的工程模式。
它并不试图让编程变得“轻松”，
而是利用 Vibe Coding 的能力，**提升工程实践的稳定性与可控性**。

---

## 1. Vibe + Coding 在做什么

Vibe + Coding 的核心思想，是将传统的 Vibe Coding **显式拆解为两个完全不同的 Agent 模块**：

- **Vibe Agent**：负责设计、思考、建模与文档化
- **Coding Agent**：负责在明确约束下执行实现

二者 **不共享任何上下文**，
唯一的通信方式是 **文档与测试**。

一个完整的循环是：

人类 + Vibe Agent 进行设计
→ 生成任务文档
→ Coding Agent 执行
→ 执行结果审计
→ 修改文档或代码
→ 进入下一轮

如此反复。

---

## 2. 为什么要如此严格地拆分

这一模式的关键价值，在于**彻底分离设计与实现**：

- 设计不再被实现细节反向污染
- 决策不再被“顺手写的代码”悄然改变
- 工程语义不再隐藏在实现细节中

它将重要的工程思考过程：

> 从“边写边想”
> 迁移为“想清楚再写”

而“写”的部分，则被完全、明确地委托给 Coding Agent。

---

## 3. 这不是捷径，而是一种工程立场

**Vibe + Coding 并不是捷径，也不是技巧集合。**

它是一种工程立场的选择：

- 用结构换取稳定
- 用文档换取记忆
- 用设计换取规模
- 用前期思考换取长期收益

你选择的不是“更快”，
而是“更可控”。

---

## 4. 必须改变的心智模型

要真正使用 Vibe + Coding，必须接受以下角色重构：

- **你是系统的唯一责任人**
  你的核心产出不是代码，而是**决策**。

- **Vibe Agent 是设计协作者**
  它的价值不在于“给出正确答案”，
  而在于：
  **帮助你把尚未成形的判断，转化为可讨论、可冻结的结构。**

- **Coding Agent 是受约束的执行者**
  它更像一名“将 ticket 变成代码的初级工程师”，
  不参与判断，只负责执行。

- **文档是冻结的共识与工程记忆**

- **测试是设计的行为契约**

---

## 5. Vibe 阶段：如何组织设计活动

在 Vibe 阶段，Vibe + Coding 使用一个固定的四阶段模型：

**输入 → 对齐 → 细化 → 冻结**

这四个阶段并不仅适用于项目顶层设计，
而是天然具备 **分型递归特性**。

你可以对：

- 整个项目
- 单个模块
- 某个子系统
- 一个具体功能

重复执行：

**输入 → 对齐 → 细化 → 冻结**

直到最终收敛到一个尺度：

> **可以被 Coding Agent 独立完成的原子任务。**

---

## 6. Coding 阶段：从冻结到提交的闭环

在 Coding 阶段，一条完整、受控的执行链路是：

冻结文档（Vibe Agent）
→ 原子任务（Vibe Agent）
→ 测试设计（Vibe Agent）
→ 测试实现（Coding Agent）
→ 代码写作（Coding Agent）
→ 实现报告（Coding Agent）
→ 回流审阅（Vibe Agent）
→ 提交确认（人类）

在这条链路中：

- 语义自上而下传递
- 责任自下而上回溯
- 每一层都有清晰的解释权边界

---

## 7. 关于失败的真正原因

Vibe + Coding 的失败，
**几乎从来不是模型能力不足**，
而是：

> **工程纪律的松动。**

当你发现流程开始变形时，不要试图：

“更努力地使用 AI”。

你真正应该做的是：

- 回到角色划分
- 回到文档
- 回到测试
- 回到冻结点

---

## 8. 最终结论

Vibe + Coding 的价值，不在于灵活，
而在于它在混乱中提供了一条：

> **可以回退的工程路径。**

当工程不再依赖隐式记忆与即兴发挥，
当决策被结构化、被冻结、可审计，
AI 才能真正成为可靠的工程执行单元。

这正是 Vibe + Coding 想要达到的目标。
