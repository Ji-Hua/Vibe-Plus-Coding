© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第五章｜示意性样例：用 Vibe + Coding 串起一次完整流程（Illustrative Walkthrough）

本章**不是一个真实、完整、可直接复现的工程案例**。
它也不试图覆盖一个项目从零到一的全部细节。

本章的唯一目的是：

> **用一个“假想但足够具体”的示例，把 Vibe + Coding 的每一个关键步骤串起来，
> 让你清楚地看到：在每一步，你应该做什么，而不是怎么写代码。**

因此，你应当把本章理解为：

- 一张流程示意图
- 一次“演练式 walkthrough”
- 一套可迁移的操作骨架

而不是：

- 完整教程
- 最佳实现方案
- 现实项目蓝本

---

## 阅读约定（非常重要）

- 本章中的示例 **刻意保持简化**
- 所有 prompt 都是**示意性 prompt**
- 输出内容 **不追求完整性，只追求方向正确**
- 示例项目（象棋）只是一个载体，而非重点

不要试图“照抄本章直接写项目”。

---

## 0. 示例问题设定（仅用于说明流程）

我们假设有这样一个工程想法：

- 项目：象棋（Chess）
- 目标：支持两人本地对战
- 交互：命令行
- 语言：Python
- 非目标：
  - GUI
  - 网络对战
  - 性能优化
  - 人机智能算法

这个问题具备两个特征：

- 规则明确
- 状态复杂

非常适合用来**展示流程，而不是展示技巧**。

---

## Step 1 — 输入：只声明问题，不让 AI 设计

### 这一阶段你在做什么

你只是告诉 Vibe Agent：

> “我们接下来要认真讨论的是这件事。”

而不是：

> “你来帮我设计 / 实现这个系统。”

### 示意性 Vibe Prompt（Input）

- 我想做一个象棋程序，使用 Python。
- 第一阶段只考虑本地双人对战，命令行即可。
- 先不要设计，也不要写代码。
- 请你先记录我的描述。
- 在我说“输入结束”之后，只做两件事：
  1) 复述你理解的需求；
  2) 列出你认为还不清楚的地方。

输入结束。

### 💡 小提示

如果 AI 已经开始讨论模块、类或实现方式，
说明你在 Input 阶段**没有成功阻止它进入设计模式**。

---

## Step 2 — 对齐：确认我们在讨论“同一件事”

### 这一阶段你在做什么

你不是在推进方案，
而是在消除误解。

对齐的目标不是“想得更好”，
而是“想得一致”。

### 示意性对齐方式

- 让 AI 复述需求
- 修正偏差
- 回答关键不确定点
- 明确非目标

### 💡 小提示

“复述你理解的需求”这种复述式prompt适用于设计足够细致，要求足够明确的输入；
“列出你认为还不清楚的地方”这种反问时prompt适用于模糊性输入，这样反问可以快速缩减设计空间。

---

## Step 3 — 细化：把问题变成结构

### 这一阶段你在做什么

你开始允许 AI 参与**结构性思考**，
但讨论对象仍然是：

- 模块
- 职责
- 数据
- 流程

而不是实现。

### 示意性 Vibe Prompt（Refine）

- 基于当前已对齐的需求：
  - 给出一个最小可行的系统结构
  - 说明模块划分与职责
  - 描述核心数据模型
  - 描述最小执行流程
- 不写代码，只输出结构化设计。

### 💡 小提示

Refine 阶段最常见的错误是：

- 过早纠结实现细节
- 试图“一次性设计最终形态”

你此时要的只是：
**一个可以被写进文档的系统模型。**

---

## Step 4 — Freeze：把讨论变成文档

### 这一阶段你在做什么

你在做一件非常关键、但经常被跳过的事：

> **把“我们现在认为对的东西”固定下来。**

### 示意性 Freeze 行为

- 要求 AI 将当前设计整理为文档
- 明确这是阶段性结论
- 明确这是后续执行的权威来源

### 💡 小提示

一个简单判断标准是：

> 如果你现在愿意把这份文档交给一个
> “只执行、不思考”的人，那 Freeze 就是合格的。

---

## Step 5 — 从文档到任务：示意性的 DFS 拆分

### 这一阶段你在做什么

你不是在规划整个项目，
而是在回答：

> “接下来，哪一小块可以被独立完成？”

### 示意性拆分结果

例如：

- Task 1：棋盘与坐标系统
- Task 2：棋子抽象
- Task 3：走子表示
- …

每一个 Task 都应该是：

- 可独立实现
- 可测试
- 可审计

---

## Step 6 — 为单个任务写清楚“该怎么执行”

### 这一阶段你在做什么

你正在把一个任务，
从“工程师能理解”，
变成“执行者也不会猜错”。

### 示意性任务文档应包含

- 任务目标
- 权威设计来源
- 范围与边界
- 行为约束
- 完成标准

### 💡 小提示

自检问题只有一个：

> **如果我是执行者，这份说明是否已经不需要猜？**

---

## Step 7 — Coding：切换会话，只执行

### 这一阶段你在做什么

你在**刻意降低 AI 的自由度**。

- 新会话
- 无历史上下文
- 只提供任务文档

### 示意性 Coding Prompt 特征

- 明确这是执行任务
- 明确权威来源
- 明确禁止事项
- 要求测试优先
- 要求实现报告

### 💡 小技巧：上下文健康信号

一个实用的小技巧是：

- 在 Coding 会话中，要求 AI 在每次回复结尾输出一个固定格式（例如当天日期）
- 一旦连续回应中该格式消失，立刻停止并新开会话

这通常意味着上下文窗口已经开始影响模型稳定性。

---

## Step 8 — 回流审阅：不是“看代码”，而是“对文档”

### 这一阶段你在做什么

你不是在问：

> “代码写得好不好？”

而是在问：

> “代码是否忠实执行了文档？”

任何偏差，都必须被明确归因到：

- 设计问题
- 或执行问题

而不是用 patch 掩盖。

---

## 本章小结

本章通过一个**刻意简化的示意样例**，
展示了 Vibe + Coding 的完整操作骨架：

- 如何开始讨论
- 如何对齐
- 如何收敛
- 如何冻结
- 如何拆解
- 如何执行
- 如何回看

你不需要记住象棋，
也不需要记住这些 prompt。

你需要记住的只有一件事：

> **在每一步，你究竟是在思考，
> 还是在执行。**

一旦这两件事被混在一起，
流程就会退化。
