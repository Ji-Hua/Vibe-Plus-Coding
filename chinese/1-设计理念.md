© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第一章｜设计理念（Design Philosophy）

在引言中，我已经说明了 Vibe + Coding 并不是一次偶然的技巧发现，而是源自真实工程实践中的反复失败与修正。本章的目的，是进一步明确这一范式背后的**工程立场与设计假设**。

---

## 0. 什么是 Vibe + Coding（明确且可执行的定义）

**Vibe + Coding 并不是一种“更聪明的 Vibe Coding”，
而是将传统 Vibe Coding 强行拆分为两个彼此分离的阶段。**

这两个阶段分别是：

- **Vibe（设计阶段）**
- **Coding（实现阶段）**

二者的关系不是协作混合，而是**职责隔离**。

### Vibe 阶段（设计阶段）

Vibe 阶段只负责一件事：

> **将人类工程师的设计意图，转化为可执行的外部结构。**

具体产出包括但不限于：

- 设计文档（Design Doc）
- 架构说明
- API 文档
- 数据结构定义
- 任务说明书
- 行为约束描述
- 测试设计（或测试意图）

在这一阶段中：

- 不追求代码实现
- 不关心语法细节
- 不允许“顺手写点代码看看”

Vibe 阶段的唯一目标，是**冻结决策，并将其外显为文档结构**。

---

### Coding 阶段（实现阶段）

Coding 阶段同样只负责一件事：

> **严格依据已有文档与测试，完成受约束的实现。**

在这一阶段中：

- 不重新讨论设计
- 不引入新的隐式假设
- 不“优化一下结构”
- 不补充未经说明的行为

Coding 阶段的输入是文档，
输出是代码。

---

### 一个必须强调的关键约束：不共享上下文

**Vibe 与 Coding 不应该共享上下文。**

这不是“推荐做法”，而是**范式成立的必要条件**。

这意味着：

- Vibe 阶段产生的所有信息，必须通过文档传递
- Coding 阶段不依赖任何“之前聊过的内容”
- 除文档与测试之外，不存在隐式沟通渠道

在工具层面，这种隔离可以通过多种方式实现：

- 使用不同工具（例如 ChatGPT 负责 Vibe，Cursor / Copilot 负责 Coding）
- 使用同一工具的不同会话窗口（例如 Copilot Chat vs Copilot Agent）
- 使用不同 Agent 实例，禁止共享历史上下文

**只要上下文是共享的，Vibe + Coding 就会退化回旧的 Vibe Coding。**

---

### 一句话总结定义

> **Vibe + Coding =
> 将 Vibe Coding 强制拆分为“设计生成文档”与“按文档实现代码”两个阶段，
> 二者职责分离、上下文隔离，仅通过文档与测试进行通信。**

如果你无法做到这一点，那么你使用的仍然是旧的 Vibe Coding。

---

## 1. 两种完全不同的编程范式

### Vibe Coding（旧范式）

本文所说的 **Vibe Coding**，指的是当前最常见的一种 AI 编程方式：

- 在单一对话中与 AI 持续交互
- 设计、实现、调试混合进行
- AI 同时承担“理解问题”和“生成代码”的角色
- 工程连续性依赖上下文窗口的隐式记忆

这种方式在以下场景中是有效的：

- 原型验证
- 一次性脚本
- 小工具
- 探索性尝试

但在中大型工程中，它往往会系统性失效：

- 设计意图在对话中逐步漂移
- 实现细节反向主导结构
- 决策被埋入代码，不可追溯
- 出现问题时，难以解释“为什么会这样”

这不是使用者不够谨慎，也不是模型不够强，
而是这种模式**本身不具备工程级稳定性**。

除非特别说明，本文中的 “Vibe Coding” 一律指该旧范式。

---

### Vibe + Coding（新范式）

**Vibe + Coding 并不是 Vibe Coding 的加强版，
而是对其进行结构性拆分。**

它将原本混杂在一起的过程，强制拆分为两个阶段：

- **Vibe：设计阶段，负责生成文档**
- **Coding：实现阶段，负责按文档执行**

二者职责分离、上下文隔离，
仅通过文档与测试进行通信。

Vibe + Coding 关注的不是如何让 AI 更聪明，
而是：

- 谁负责思考
- 谁负责执行
- 决策如何被冻结
- 系统语义如何被保存

在这一范式中：

- 人类工程师始终是项目所有人，负责设计与取舍
- AI 不再参与设计判断
- 而是作为**受约束的执行角色**存在

只要这一分离被破坏，
流程就会不可避免地退化回旧的 Vibe Coding。

---

## 2. 这个范式真正要解决的问题

在现实的软件开发中，工程师的大量精力往往并未消耗在真正困难的地方。

相反，时间常常被以下工作吞噬：

- 胶水代码
- 重复结构
- 模板式逻辑
- 框架约束下的样板实现
- 与核心设计无关的工程噪音

这些工作并不复杂，却持续消耗注意力。

与此同时，真正决定系统质量与寿命的部分——

- 架构设计
- 抽象建模
- 接口边界
- 不变量定义
- 长期可维护性判断

却只能在零散时间中被仓促完成。

Vibe + Coding 并不是为了“让一个人写更多代码”，
而是为了回答一个更现实的问题：

> **如何让工程师把有限的认知资源，用在真正不可替代的地方。**

因此，它追求的也不是“效率最大化”，
而是：

> **工程责任的完整性。**

### 没有万能药

**Vibe + Coding 的目标，从来不是让编程变得轻松。**

编程本身就不是一项轻松的工作。
任何试图将复杂工程描述为“只要提示词写得好就能完成”“AI 可以自动搞定一切”的叙事，本质上都是对工程现实的误判。

Vibe + Coding 并不试图减少思考量，
它真正做的事情只有一件：

> **重新分配思考发生的位置、形式与责任。**

---

## 3. 一个必须正视的现实：上下文是脆弱的

在当前阶段，所有大模型都存在一个无法回避的限制：

**上下文窗口是有限且不稳定的。**

当任务规模扩大时，这一限制会系统性地暴露出来：

- 早期设计决策逐渐被遗忘
- 模块之间的隐式约束消失
- 实现呈现出“局部正确、整体错误”的特征
- 问题出现后，难以回溯根因

依赖“持续对话记忆”来完成复杂工程，本身就是一种高风险行为。

这并不是模型的问题，而是**工程假设的问题**。

---

## 4. Vibe + Coding 的核心假设

Vibe + Coding 建立在一个清晰而克制的假设之上：

> **AI 不适合长期持有复杂工程的整体语义。**

因此，我们不应要求 AI“记住整个项目”，
而应当主动改变工程组织方式：

- 将复杂问题拆分为相互独立的子任务
- 为每个子任务提供完整、封闭、可理解的说明
- 在可控上下文内完成执行
- 通过文档与测试保存决策结果

在这种结构下，AI 的不稳定性被限制在局部范围内，
而系统的整体语义由人类工程师把握。

---

## 5. 文档的角色被重新定义

在 Vibe + Coding 中，文档并不是事后补写的记录，
而是工程结构的一部分。

文档承担的是：

- 设计共识的承载体
- 决策冻结的边界
- 行为可审计的语义来源

它同时服务于三个对象：

- 向 Coding 阶段明确执行约束
- 向 Vibe 阶段提供稳定的记忆锚点
- 向未来的自己保存上下文

工程由此从“连续对话”转变为：

**离散、可版本化、可回溯的决策序列。**

---

## 6. 思考被前移，而不是被减少

需要明确的一点是：

Vibe + Coding 并不会减少思考量。

恰恰相反，它要求更高强度的前期思考。

许多原本可以在“写代码时顺便决定”的问题，
现在必须在 Vibe 阶段被显式想清楚、写下来并冻结。

这是一种明确的工程取舍：

- 用更多前期设计投入
- 换取更少低级实现劳动
- 换取更高的长期可维护性

如果你习惯于边写边想、先跑起来再说，
这一范式可能会让你感到不适。

但如果你认同设计优先、测试先行的工程方式，
你往往会获得更强的掌控感。

---

## 7. 关于适用范围的原则性说明

Vibe + Coding 并不是通用解法。

它更适合用于**设计主导型问题**，而非实现主导型问题。

当一个项目的核心难点在于：

- 系统如何拆分
- 抽象是否稳定
- 边界是否清晰
- 不变量能否长期成立

那么，设计质量远比实现速度重要。

在这类问题中，Vibe + Coding 的价值最为明显。

相反，当问题本质仍然是：

- 能不能做出来
- 性能能不能达标
- 方案是否可行

那么提前冻结设计往往是不合适的。

关于具体的误用场景与失败模式，将在后续章节中详细讨论。

---

## 8. 本章小结

Vibe + Coding 并不是捷径，也不是技巧集合。
它是一种工程立场的选择：

- 用结构换取稳定
- 用文档换取记忆
- 用设计换取规模
- 用前期思考换取长期收益

当工程师专注于“该做什么、为什么如此”，
而 AI 专注于“如何在约束下正确执行”，
协作才真正成立。

这正是本指南试图建立的核心设计理念。
