© 2026 Ji Hua.
This repository documents the Vibe + Coding methodology.
Licensed under CC BY-NC-ND 4.0.

Vibe + Coding — Version 0.1

# 第六章｜常见错误与工程取舍

Vibe + Coding 并不是一个“只要照着做就一定成功”的流程。
它是一套**高度依赖工程纪律的范式**。

一旦关键约束被破坏，流程往往不会立刻崩溃，
而是以一种非常隐蔽的方式逐渐退化，最终回到旧的 Vibe Coding。

本章的目标并不是列举“坏习惯”，
而是帮助你识别那些**正在说明你用错了范式、或不该使用该范式的信号**，
并在工程真正失控之前做出取舍与纠偏。

---

## 1. 最危险的反模式：角色混合

这是 Vibe + Coding 中**最常见、也是最致命的失败来源**。

### 表现形式

- 在 Coding 阶段讨论架构设计
- 让 Coding Agent“顺便优化一下结构”
- 设计尚未冻结就开始写代码
- 在 Vibe 阶段不断插入实现细节

### 后果

- 实现开始反向主导设计
- 文档逐渐失去权威性
- 决策被隐藏进代码细节
- 系统进入不可审计状态

### 工程含义

一旦角色边界被打破，
Vibe + Coding 就已经不再成立。

### 修正方式

- 立即停止执行
- 回到文档
- 明确当前处于 Vibe 还是 Coding 阶段
- 恢复角色隔离与上下文隔离

---

## 2. 用代码补丁掩盖设计问题

这是第二常见、但更隐蔽的退化路径。

### 表现形式

- “这个地方有点怪，先 patch 一下吧”
- “先让它跑起来，之后再补文档”
- “文档没写清，但代码这样也行”

### 问题本质

**设计缺陷被转化为实现复杂度。**

短期看似高效，
长期结果几乎必然是：

- 设计越来越空
- 代码越来越重
- 系统逐渐无人敢改

### 原则

任何非预期行为，都必须回到文档层解决。

**代码不能解释设计。**
只有文档拥有语义解释权。

---

## 3. 文档漂移：说的和做的已经不是一回事

### 表现形式

- 文档长期不再更新
- 实现明显超出文档范围
- 测试开始验证“真实行为”，而非设计行为

### 危险信号

- 新成员只能通过读代码理解系统
- 文档仅剩“历史痕迹价值”

这意味着：

> 工程已经退化为隐式知识系统。

### 修正方式

- 暂停新功能开发
- 对文档与实现进行系统性对账
- 明确哪些行为是事实，哪些应被废弃

---

## 4. 过度信任 AI 的“聪明”

这是一个心理层面的反模式。

### 表现形式

- “它应该能理解我的意思”
- “这个不用写文档也能明白吧”
- “模型这么强，不会出错的”

### 现实结果

- 隐式假设大量积累
- 小偏差被快速放大
- 错误难以复现、难以解释

Vibe + Coding 的核心前提是：

> **AI 只在约束之内可靠。**

任何脱离文档与测试的“聪明”，
都应被视为工程风险，而非能力优势。

---

## 5. 文档过度形式化

反模式并不只来自“太少”，
也可能来自“太多”。

### 表现形式

- 文档追求完美规格
- 试图一次性定义所有细节
- 写文档的成本接近写代码

### 后果

- 设计僵化
- 迭代速度急剧下降
- 工程失去探索空间

### 原则

文档的目标是：

> **足够清晰以执行，但不过度限制未来。**

文档冻结的是阶段性共识，而不是终极真理。

---

## 6. 把探索性问题强行塞进范式

这是一个非常常见的误用场景。

### 表现形式

- 尚不确定是否可行的算法
- 尚未验证的技术路线
- 强探索性、强不确定性问题

却试图：

- 编写完整设计文档
- 定义严格测试
- 冻结实现路径

### 结果

- 大量无效文档
- 设计频繁被推翻
- 心理负担极重

### 工程判断

当问题仍然是：

“能不能做到？”

而不是：

“怎么把它做好？”

此时使用 Vibe + Coding，本身就是一种错误。

---

## 7. 不适用场景被强行使用

以下场景一旦强行套用 Vibe + Coding，
几乎必然会出现前述所有退化问题：

- 一次性脚本
- 强 UI / UX 驱动的前端项目
- 高度依赖试错与调参的实现型任务
- 历史负担极重的屎山系统维护

在这些场景中：

- 文档成本 ≈ 实现成本
- 冻结设计缺乏现实基础

**范式的失败，并不意味着方法错误，
而是使用场景错误。**

---

## 8. 忽略集成层的风险

### 表现形式

- 单模块测试全部通过
- 系统整体运行失败
- 模块接口无法组合

### 原因

设计阶段过度关注模块内部，
而忽略模块之间的组合行为。

### 正确做法

- 为模块边界编写集成测试
- 尽早跑通最小可用路径
- 不等所有模块完成再合龙

---

## 9. 静默重构（Silent Refactor）

### 表现形式

- “顺手整理了一下代码结构”
- “只是重命名，不影响逻辑”
- 没有对应文档变更

### 风险

- 设计语义被悄然改变
- 历史决策丢失
- 调试与回溯成本激增

### 原则

> **没有文档记录的重构，不存在。**

---

## 10. 失控的早期信号

以下信号一旦出现，应立即警惕：

- 你开始频繁直接改代码
- 文档长期不再更新
- Coding Agent 经常“猜”你的意图
- 你需要反复解释同一件事
- 修 bug 时很难说明“为什么错”

这些都意味着：

> 工程正在偏离 Vibe + Coding 范式。

---

## 11. 本章小结

Vibe + Coding 的失败，
几乎从来不是模型能力不足，
而是**工程纪律的松动**。

当你发现流程开始变形时，不要试图“更努力地使用 AI”，
而应当：

- 回到角色划分
- 回到文档
- 回到测试
- 回到冻结点

Vibe + Coding 的价值不在于灵活，
而在于它在混乱中提供了一条**可以回退的路径**。
